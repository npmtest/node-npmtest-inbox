{"/home/travis/build/npmtest/node-npmtest-inbox/test.js":"/* istanbul instrument in package npmtest_inbox */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-inbox/lib.npmtest_inbox.js":"/* istanbul instrument in package npmtest_inbox */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_inbox = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_inbox = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-inbox/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-inbox && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_inbox */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_inbox\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_inbox.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_inbox.rollup.js'] =\n            local.assetsDict['/assets.npmtest_inbox.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_inbox.__dirname +\n                    '/lib.npmtest_inbox.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-inbox/node_modules/inbox/lib/client.js":"\"use strict\";\n\n/**\n * @fileOverview Provides an simple API for IMAP mailbox access\n * @author Andris Reinman\n */\n\n// TODO: On error close the connection when needed\n\nvar Stream = require(\"stream\").Stream,\n    utillib = require(\"util\"),\n    net = require(\"net\"),\n    tls = require(\"tls\"),\n    starttls = require(\"./starttls\").starttls,\n    IMAPLineParser = require(\"./lineparser\"),\n    mimelib = require(\"mimelib\"),\n    xoauth = require(\"./xoauth\"),\n    xoauth2 = require(\"xoauth2\"),\n    utf7 = require('utf7').imap,\n    mailboxlib = require(\"./mailbox\"),\n    Mailbox = mailboxlib.Mailbox,\n    detectMailboxType = mailboxlib.detectMailboxType;\n\n/**\n * Expose to the world\n * @namespace inbox\n */\nmodule.exports.createConnection = createConnection;\nmodule.exports.createXOAuthGenerator = createXOAuthGenerator;\nmodule.exports.IMAPClient = IMAPClient;\n\n/**\n * Create an IMAP inbox object, shorthand for new IMAPClient.\n *\n * @memberOf inbox\n * @param {Number} port IMAP server port to connect to\n * @param {String} host IMAP server hostname\n * @param {Object} options Options object for authentication etc.\n */\nfunction createConnection(port, host, options){\n    return new IMAPClient(port, host, options);\n}\n\n/**\n * Create a XOAUTH login token generator\n *\n * @memberOf inbox\n * @param {Object} options Options object, see {@see xoauth}\n */\nfunction createXOAuthGenerator(options){\n    return new xoauth.XOAuthGenerator(options);\n}\n\n/**\n * Creates an IMAP connection object for communicating with the server\n *\n * @constructor\n * @memberOf inbox\n * @param {Number} port IMAP server port to connect to\n * @param {String} host IMAP server hostname\n * @param {String} options Options object for authentication etc.\n */\nfunction IMAPClient(port, host, options){\n    Stream.call(this);\n\n    /**\n     * Make this stream writeable. For future reference only, currently not needed\n     */\n    this.writable = true;\n\n    /**\n     * Make this stream readable. Should be on by default though\n     */\n    this.readable = true;\n\n    /**\n     * Options object for this instance\n     */\n    this.options = options || {};\n\n    /**\n     * Port to use for connecting to the server\n     */\n    this.port = port || (this.options.secureConnection ? 993 : 143);\n\n    /**\n     * Server hostname\n     */\n    this.host = host || \"localhost\";\n\n    /**\n     * If set to true, print traffic between client and server to the console\n     */\n    this.debug = !!this.options.debug;\n\n    /**\n     * XOAuth2 token generator if XOAUTH2 auth is used\n     * @private\n     */\n    this._xoauth2 = false;\n    this._xoauth2RetryCount = 0;\n    this._xoauth2UntaggedResponse = false;\n\n    if(typeof this.options.auth && typeof this.options.auth.XOAuth2){\n        if(typeof this.options.auth.XOAuth2 == \"object\" && typeof this.options.auth.XOAuth2.getToken == \"function\"){\n            this._xoauth2 = this.options.auth.XOAuth2;\n        }else if(typeof this.options.auth.XOAuth2 == \"object\"){\n            if(!this.options.auth.XOAuth2.user && this.options.auth.user){\n                this.options.auth.XOAuth2.user = this.options.auth.user;\n            }\n            this._xoauth2 = xoauth2.createXOAuth2Generator(this.options.auth.XOAuth2);\n        }\n    }\n\n    this._init();\n}\nutillib.inherits(IMAPClient, Stream);\n\n/**\n * States constants for the client FSM.\n */\nIMAPClient.prototype.states = {\n    NONE: 0x1,\n    PREAUTH: 0x2,\n    AUTH: 0x3,\n    SELECTED: 0x4,\n    LOGOUT: 0x5\n};\n\n/**\n * States constants for current command parsing.\n */\nIMAPClient.prototype.modes = {\n    COMMAND: 0x1,\n    DATA: 0x2\n};\n\n/**\n * Delay for breaking IDLE loop and running NOOP\n */\nIMAPClient.prototype.IDLE_TIMEOUT = 60 * 1000;\n\n/**\n * Delay for entering IDLE mode after any command\n */\nIMAPClient.prototype.ENTER_IDLE = 1 * 1000;\n\n/**\n * How much time to wait for the initial greeting\n */\nIMAPClient.prototype.GREETING_TIMEOUT = 15 * 1000;\n\n/**\n * Reset instance variables\n */\nIMAPClient.prototype._init = function(){\n\n    /**\n     * Should the connection be over TLS or NET\n     */\n    this.options.secureConnection = !!this.options.secureConnection;\n\n    /**\n     * Authentication details\n     */\n    this.options.auth = this.options.auth || {user: \"\", pass:\"\"};\n\n    /**\n     * Connection socket to the server\n     */\n    this._connection = false;\n\n    /**\n     * Is the connection currently in secure mode, changes with STARTTLS\n     */\n    this._secureMode = !!this.options.secureConnection;\n\n    /**\n     * Current protocol state.\n     */\n    this._currentState = this.states.NONE;\n\n    /**\n     * Current stream mode for incoming data\n     */\n    this._currentMode = this.modes.COMMAND;\n\n    /**\n     * Expected remaining data length on stream data mode\n     */\n    this._expectedDataLength = 0;\n\n    /**\n     * Data that was not part of the last command\n     */\n    this._remainder = \"\";\n\n    /**\n     * Counter for generating unique command tags\n     */\n    this._tagCounter = 0;\n\n    /**\n     * Currently active command\n     */\n    this._currentRequest = false;\n\n    /**\n     * Unprocessed commands\n     */\n    this._commandQueue = [];\n\n    /**\n     * Server capabilities\n     */\n    this._capabilities = [];\n\n    /**\n     * Are the capabilities updated\n     */\n    this._updatedCapabilities = false;\n\n    /**\n     * Currently in idle\n     */\n    this.idling = false;\n\n    /**\n     * Currently \"nooping\" when idle not available\n     */\n    this.nooping = false;\n\n    /**\n     * Waiting for idle start after issuing IDLE command\n     */\n    this._idleWait = false;\n\n    /**\n     * Waiting for the idle to end\n     */\n    this._idleEnd = false;\n\n    /**\n     * Timer to run NOOP when in idle\n     */\n    this._idleTimer = false;\n\n    /**\n     * Timer for entering idle mode after other commands\n     */\n    this._shouldIdleTimer = true;\n\n    /**\n     * If true check mail before entering idle\n     */\n    this._shouldCheckOnIdle = false;\n\n    /**\n     * Timeout to wait for a successful greeting from the server\n     */\n    this._greetingTimeout = false;\n\n    /**\n     * Server ID\n     */\n     this._serverId = {};\n\n    /**\n     * Should the FETCH responses collected into an array\n     */\n    this._collectMailList = false;\n\n    /**\n     * An array of collected FETCH responses\n     */\n    this._mailList = [];\n\n    /**\n     * If set to true emit FETCH responses as new emails\n     */\n    this._checkForNewMail = false;\n\n    /**\n     * Currently selected mailbox data\n     */\n    this._selectedMailbox = {};\n\n    /**\n     * Currently streaming possible literal values\n     */\n    this._literalStreaming = false;\n\n    /**\n     * Message Stream object for streaming requested messages\n     */\n    this._messageStream = false;\n\n    /**\n     * Literal handler\n     */\n    this._literalHandler = false;\n\n    /**\n     * Personal mailbox root\n     */\n    this._rootPath = \"\";\n\n    /**\n     * Delimiter for mailbox hierarchy\n     */\n    this._mailboxDelimiter = \"/\";\n\n    /**\n     * Default INBOX name\n     */\n    this._inboxName = \"INBOX\";\n\n    /**\n     * Default Sent folder name\n     */\n    this._outgoingName = this.options.outgoingName || \"\";\n\n    /**\n     * Active mailbox list\n     */\n    this._mailboxList = [];\n\n    /**\n     * Is CONDSTORE enabled or not\n     */\n    this._condstoreEnabled = false;\n\n    /**\n     * Ignore all incoming data while in TLS negotiations\n     */\n    this._ignoreData = false;\n\n    /**\n     * Keep IMAP log for error trace\n     */\n    this._log = [];\n\n    /**\n     * IMAP log length in lines\n     */\n    this._logLength = 10;\n\n    /**\n     * Root mailbox\n     */\n    this._rootMailbox = new Mailbox({client: this});\n\n    /**\n     * Lineparser object to feed the incoming data to\n     */\n    this.lineparser = new IMAPLineParser();\n\n    /**\n     * Initially send the incoming data to greeting handler\n     */\n    this._currentHandler = this._handlerGreeting;\n\n    this.lineparser.on(\"line\", this._onServerResponse.bind(this));\n    this.lineparser.on(\"log\", this._onServerLog.bind(this, \"S\"));\n};\n\n/**\n * Connect to the server using either TLS or NET\n */\nIMAPClient.prototype.connect = function(){\n\n    if(this.options.secureConnection){\n        this._connection = tls.connect(this.port, this.host, {rejectUnauthorized: false}, this._onConnect.bind(this));\n    }else{\n        this._connection = net.connect(this.port, this.host);\n        this._connection.on(\"connect\", this._onConnect.bind(this));\n    }\n\n    this._connection.on(\"error\", this._onError.bind(this));\n\n    this._greetingTimeout = setTimeout(this._handleGreetingTimeout.bind(this), this.GREETING_TIMEOUT);\n};\n\n// CONNECTION EVENTS\n\n/**\n * 'connect' event for the connection to the server. Setup other events when connected\n *\n * @event\n */\nIMAPClient.prototype._onConnect = function(){\n\n    if(this.debug){\n        console.log(\"Connection to server opened\");\n    }\n\n    if(\"setKeepAlive\" in this._connection){\n        this._connection.setKeepAlive(true);\n    }else if(this._connection.socket && \"setKeepAlive\" in this._connection.socket){\n        this._connection.socket.setKeepAlive(true); // secure connection\n    }\n\n    this._connection.on(\"data\", this._onData.bind(this));\n    this._connection.on(\"close\", this._onClose.bind(this));\n    this._connection.on(\"end\", this._onEnd.bind(this));\n\n};\n\n/**\n * 'data' event coming from the server connection. Split the lines on line breaks\n * and if in COMMAND mode pass the line to the line parser and when in DATA\n * mode, pass it as a literal or stream if needed. If there's a remainder left from\n * the end of the line, rerun the function with it\n *\n * @event\n * @param {Buffer} chunk incoming binary data chunk\n */\nIMAPClient.prototype._onData = function(chunk){\n    if(this._ignoreData){\n        // TLS negotiations going on, ignore everything received\n        return;\n    }\n\n    var data = chunk && chunk.toString(\"binary\") || \"\",\n        line, match;\n\n    if(this._remainder){\n        data = this._remainder + data;\n        this._remainder = \"\";\n    }\n\n    if(this._currentMode == this.modes.DATA){\n        if(this._expectedDataLength <= data.length){\n\n            if(this._expectedDataLength){\n\n                if(!this._literalStreaming){\n                    this.lineparser.writeLiteral(data.substr(0, this._expectedDataLength));\n                }else{\n                    this._messageStream.emit(\"data\", new Buffer(data.substr(0, this._expectedDataLength), \"binary\"));\n                }\n\n                this._remainder = data.substr(this._expectedDataLength);\n                this._expectedDataLength = 0;\n            }else{\n                this._remainder = data;\n            }\n\n            this._currentMode = this.modes.COMMAND;\n\n            return this._onData(); // rerun with the remainder\n        }else{\n\n            if(!this._literalStreaming){\n                this.lineparser.writeLiteral(data);\n            }else{\n                this._messageStream.emit(\"data\", new Buffer(data, \"binary\"));\n            }\n\n            this._expectedDataLength -= data.length;\n            return;\n        }\n    }\n\n    if(this._currentMode == this.modes.COMMAND){\n        if((match = data.match(/\\r?\\n/))){ // find the line ending\n            line = data.substr(0, match.index);\n            this._remainder = data.substr(match.index + match[0].length) || \"\";\n\n            if(this.debug){\n                console.log(\"SERVER: \"+line);\n            }\n\n            // check if the line ends with a literal notion\n            if((match = line.match(/\\{(\\d+)\\}\\s*$/))){\n                this._expectedDataLength = Number(match[1]);\n                this.lineparser.write(line);\n\n                this._currentMode = this.modes.DATA;\n\n                if(this._literalStreaming){\n                    this.lineparser.writeLiteral(\"\"); // create empty literal object\n                }\n            }else{\n                this.lineparser.end(line);\n            }\n\n            if(this._remainder){\n                return this._onData(); // rerun with the remainder\n            }\n        }else{\n            this._remainder = data; // keep it for later\n        }\n    }\n};\n\n/**\n * 'close' event when disconnected from the server\n * @event\n */\nIMAPClient.prototype._onClose = function(){\n    if(this.debug){\n        console.log(\"EVENT: CLOSE\");\n    }\n\n    this._close();\n};\n\n/**\n * 'end' event when disconnected from the server\n * @event\n */\nIMAPClient.prototype._onEnd = function(){\n    this.emit(\"end\");\n\n    if(this.debug){\n        console.log(\"EVENT: END\");\n    }\n\n    this._close();\n};\n\n/**\n * 'error' event, re-emit it\n * @event\n */\nIMAPClient.prototype._onError = function(error){\n    this.emit(\"error\", error);\n};\n\n\n// INCOMING COMMANDS\n\n/**\n * When the input command has been parsed pass it to the current command handler.\n * Basically there's just two - the initial greeting handler and universal\n * response router\n *\n * @param {Array} data Parsed command, split into parameters\n */\nIMAPClient.prototype._onServerResponse = function(data){\n    this._currentHandler(data);\n};\n\n/*\n * Log IMAP commands into ._log array\n *\n * @param {String} data IMAP command line\n */\nIMAPClient.prototype._onServerLog = function(type, data){\n    this._log.unshift((type?type + \": \" :\"\") + (data || \"\").toString().trim());\n    if(this._log.length > this._logLength){\n        this._log.pop();\n    }\n};\n\n/**\n * Run as the handler for the initial command coming from the server. If it\n * is a greeting with status OK, enter PREAUTH state and run CAPABILITY\n * command\n *\n * @param {Array} data Parsed command\n */\nIMAPClient.prototype._handlerGreeting = function(data){\n    clearTimeout(this._greetingTimeout);\n\n    if(!data || !Array.isArray(data)){\n        throw new Error(\"Invalid input\");\n    }\n\n    if(data[0] != \"*\" && data[1] != \"OK\"){\n        var error = new Error(\"Bad greeting from the server\");\n        error.errorType = \"ProtocolError\";\n        error.errorLog = this._log.slice(0, this._logLength);\n        this.emit(\"error\", error);\n        this._close();\n        return;\n    }\n\n    this._currentState = this.states.PREAUTH;\n    this._currentHandler = this._responseRouter;\n\n    this._send(\"CAPABILITY\", this._handlerTaggedCapability.bind(this));\n};\n\n/**\n * When the greeting is not received in GREETING_TIMEOUT time,\n * emit an error and close the socket\n */\nIMAPClient.prototype._handleGreetingTimeout = function(){\n    var error = new Error(\"Timeout waiting for a greeting\");\n    error.errorType = \"TimeoutError\";\n    this.emit(\"error\", error);\n    this._close();\n};\n\n/**\n * Checks the command data and routes it to the according handler\n *\n * @param {Array} data Parsed command\n */\nIMAPClient.prototype._responseRouter = function(data){\n    if(!data || !Array.isArray(data)){\n        return;\n    }\n\n    // Handle tagged commands\n    if(this._currentRequest && this._currentRequest.tag == data[0]){\n        this._currentRequest.callback(data[1], data.slice(2));\n        return;\n    }\n\n    // handle commands tagged with +\n    if(data[0]==\"+\"){\n        if(this._idleWait){\n            this._handlerUntaggedIdle();\n        }\n\n        if(this._literalHandler){\n            this._literalHandler(data.slice(1));\n        }\n    }else if(this._literalHandler){\n        this._literalHandler = null;\n    }\n\n    // handle untagged commands (tagged with *)\n    if(data[0]==\"*\"){\n        switch(data[1]){\n            case \"CAPABILITY\":\n                this._handlerUntaggedCapability(data.slice(2));\n                return;\n            case \"ID\":\n                this._handlerUntaggedId(data.slice(2));\n                return;\n            case \"ENABLED\":\n                this._handlerUntaggedEnabled(data.slice(2));\n                return;\n            case \"FLAGS\":\n                this._selectedMailbox.flags = data[2] || [];\n                return;\n            case \"SEARCH\":\n                this._handlerUntaggedSearch(data.slice(2));\n                return;\n            case \"XLIST\":\n            case \"LIST\":\n                this._handlerUntaggedList(data.slice(2));\n                return;\n            case \"LSUB\":\n                this._handlerUntaggedLsub(data.slice(2));\n                return;\n            case \"OK\":\n                if(typeof data[2] == \"object\"){\n                    if(Array.isArray(data[2].params)){\n                        if(data[2].params[0] == \"UIDVALIDITY\"){\n                            this._selectedMailbox.UIDValidity = data[2].params[1];\n                            return;\n                        }else if(data[2].params[0] == \"UIDNEXT\"){\n                            this._selectedMailbox.UIDNext = data[2].params[1];\n                            return;\n                        }else if(data[2].params[0] == \"HIGHESTMODSEQ\"){\n                            this._selectedMailbox.highestModSeq = Number(data[2].params[1]);\n                            return;\n                        }else if(data[2].params[0] == \"UNSEEN\"){\n                            this._selectedMailbox.unseen = data[2].params[1];\n                            return;\n                        }else if(data[2].params[0] == \"PERMANENTFLAGS\"){\n                            this._selectedMailbox.permanentFlags = data[2].params[1] || [];\n                            return;\n                        }\n                    }\n                }\n                return;\n        }\n\n        if(!isNaN(data[1]) && data[2] == \"FETCH\"){\n            this._handlerUntaggedFetch(data);\n            return;\n        }\n\n        if(!isNaN(data[1]) && data[2] == \"EXPUNGE\"){\n            if(this._selectedMailbox.count){\n                this._selectedMailbox.count--;\n            }\n        }\n\n        if(!isNaN(data[1]) && data[2] == \"EXISTS\"){\n            if(this._selectedMailbox.count != Number(data[1])){\n                this._selectedMailbox.count = Number(data[1]) || this._selectedMailbox.count || 0;\n                if(this.idling || this.nooping){\n                    this._checkNewMail();\n                }\n            }\n            return;\n        }\n\n    }\n};\n\n// OUTGOING COMMANDS\n\n/**\n * Prepend a tag for a command and put into command queue\n *\n * @param {String} data Command to be sent to the server\n * @param {Function} [callback] Callback function to run when the command is completed\n * @param {Function} [prewrite] Function to run before the command is sent\n */\nIMAPClient.prototype._send = function(data, callback, prewrite){\n    data = (data || \"\").toString();\n    var tag = \"A\" + (++this._tagCounter);\n\n    this._commandQueue.push({tag: tag, data: tag + \" \" + data + \"\\r\\n\", callback: callback, prewrite: prewrite});\n\n    if(this.idling || !this._currentRequest){\n        this._processCommandQueue();\n    }\n};\n\n/**\n * Send a command form the command queue to the server\n */\nIMAPClient.prototype._processCommandQueue = function(){\n\n    if(!this._commandQueue.length || !this._connection){\n        return;\n    }\n\n    // If the client is currently on idle, stop it\n    clearTimeout(this._shouldIdleTimer);\n    clearTimeout(this._idleTimer);\n    if(this._idleWait || this.idling){\n        if(!this._idleWait && this.idling && !this._idleEnd){\n            if(this.debug){\n                console.log(\"CLIENT: DONE\");\n            }\n            this._onServerLog(\"C\", \"DONE\");\n            this._connection.write(\"DONE\\r\\n\");\n            this._idleEnd = true;\n        }\n        setTimeout(this._processCommandQueue.bind(this), 100);\n        return;\n    }\n\n    var command = this._commandQueue.shift();\n\n    if(typeof command.prewrite == \"function\"){\n        command.prewrite();\n    }\n\n    this._onServerLog(\"C\", command.data);\n    this._connection.write(command.data);\n\n    if(this.debug){\n        console.log(\"CLIENT: \"+ (command.data || \"\").trim());\n    }\n\n    this._currentRequest = {\n        tag: command.tag,\n        callback: (function(status, params){\n\n            clearTimeout(this._shouldIdleTimer);\n            clearTimeout(this._idleTimer);\n            if(!this.idling && !this._idleWait && this._currentState == this.states.SELECTED){\n                this._shouldIdleTimer = setTimeout(this.idle.bind(this), this.ENTER_IDLE);\n            }\n\n            if(typeof command.callback == \"function\"){\n                command.callback(status, params);\n            }\n            this._currentRequest = false;\n\n            this._processCommandQueue();\n        }).bind(this)\n    };\n};\n\n// HANDLERS FOR TAGGED RESPONSES\n\n/**\n * Handle tagged CAPABILITY. If in plaintext mode and STARTTLS is advertised,\n * run STARTTLS, otherwise report success to _postCapability()\n *\n * @param {String} status If \"OK\" then the command succeeded\n */\nIMAPClient.prototype._handlerTaggedCapability = function(status){\n    if(status == \"OK\"){\n        if(!this._secureMode && this._capabilities.indexOf(\"STARTTLS\")>=0){\n            this._send(\"STARTTLS\", this._handlerTaggedStartTLS.bind(this));\n            return;\n        }\n\n        this._postCapability();\n    }else{\n        var error = new Error(\"Invalid capability response\");\n        error.errorType = \"ProtocolError\";\n        error.errorLog = this._log.slice(0, this._logLength);\n        this.emit(\"error\", error);\n        this._close();\n    }\n};\n\n/**\n * Handle tagged STARTTLS. If status is OK perform a TLS handshake and rerun\n * CAPABILITY on success.\n *\n * @param {String} status If \"OK\" then the command succeeded\n */\nIMAPClient.prototype._handlerTaggedStartTLS = function(status){\n    if(status == \"OK\"){\n        this._ignoreData = true;\n        starttls(this._connection, (function(socket){\n\n            this._connection = socket;\n            this._ignoreData = false;\n            this._secureMode = true;\n            this._connection.on(\"data\", this._onData.bind(this));\n\n            if(\"setKeepAlive\" in this._connection){\n                this._connection.setKeepAlive(true);\n            }else if(this._connection.socket && \"setKeepAlive\" in this._connection.socket){\n                this._connection.socket.setKeepAlive(true); // secure connection\n            }\n\n            this._send(\"CAPABILITY\", this._handlerTaggedCapability.bind(this));\n        }).bind(this));\n    }else{\n        var error = new Error(\"Invalid starttls response\");\n        error.errorType = \"TLSError\";\n        error.errorLog = this._log.slice(0, this._logLength);\n        this.emit(\"error\", error);\n        this._close();\n    }\n};\n\n/**\n * Handle LOGIN response. If status is OK, consider the user logged in.\n *\n * @param {String} status If \"OK\" then the command succeeded\n */\nIMAPClient.prototype._handlerTaggedLogin = function(status){\n    if(status == \"OK\"){\n        this._xoauth2RetryCount = 0;\n        this._xoauth2UntaggedResponse  = false;\n        this._currentState = this.states.AUTH;\n        if(!this._updatedCapabilities){\n            this._send(\"CAPABILITY\", this._handlerTaggedCapability.bind(this));\n        }else{\n            this._postAuth();\n        }\n    }else{\n        if(this._xoauth2 && this._xoauth2UntaggedResponse && this._xoauth2RetryCount && this._xoauth2RetryCount < 3){\n            this._xoauth2.generateToken((function(err){\n                var error;\n                if(err){\n                    if(typeof err != \"object\"){\n                        error = new Error(err.toString());\n                    }else{\n                       error = err;\n                    }\n                    error.errorType = \"XOAUTH2Error\";\n                    error.errorLog = this._log.slice(0, this._logLength);\n                    this.emit(\"error\", error);\n                    return;\n                }\n                this._postCapability();\n            }).bind(this));\n        }else{\n            var error = new Error(\"Authentication failed\");\n            error.errorType = \"AuthenticationError\";\n            error.errorLog = this._log.slice(0, this._logLength);\n            this.emit(\"error\", error);\n            this._close();\n        }\n    }\n};\n\n/**\n * Handle ID command. We don't reaaly care if the ID succeeded or\n * not as it is just some informational data. If it failed we still might be\n * able to access the mailbox\n */\nIMAPClient.prototype._handlerTaggedId = function(){\n    this._postReady();\n};\n\n/**\n * Handle CONDSTORE command. We don't reaaly care if the CONDSTORE succeeded or\n * not as it is just some informational data. If it failed we still might be\n * able to access the mailbox\n */\nIMAPClient.prototype._handlerTaggedCondstore = function(){\n    var clientData = {};\n\n    if(this.options.clientId){\n        Object.keys(this.options.clientId).forEach((function(key){\n            clientData[key] = this.options.clientId[key];\n        }).bind(this));\n    }\n\n    clientData = Object.keys(clientData).map((function(key){\n            return this._escapeString(key) + \" \" + this._escapeString(clientData[key]);\n        }).bind(this)).join(\" \");\n\n    if(this._capabilities.indexOf(\"ID\")>=0){\n        if(clientData.length){\n            this._send(\"ID (\" + clientData + \")\", this._handlerTaggedId.bind(this));\n        }else{\n            this._send(\"ID NIL\", this._handlerTaggedId.bind(this));\n        }\n    }else{\n        this._postReady();\n    }\n};\n\n/**\n * Handle mailbox listing with LSUB\n *\n * @param {String} status If \"OK\" then the command succeeded\n */\nIMAPClient.prototype._handlerTaggedLsub = function(xinfo, callback, status){\n    if(status != \"OK\"){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Mailbox listing failed\"));\n        }\n        return;\n    }\n\n    var curXinfo, curName;\n\n    for(var i=0, len = xinfo.length; i<len; i++){\n\n        curXinfo = xinfo[i];\n        curXinfo.tags = curXinfo.tags || [];\n\n        curName = curXinfo.name || \"\";\n        if(curXinfo.tags.indexOf(\"\\\\Inbox\")>=0){\n            curName = \"INBOX\";\n        }\n\n        for(var j=0, jlen = this._mailboxList.length; j<jlen; j++){\n            if(curName == this._mailboxList[j].name){\n\n                this._mailboxList[j].name = curXinfo.name || this._mailboxList[j].name || \"\";\n                this._mailboxList[j].tags = curXinfo.tags;\n\n                if(curXinfo.tags.indexOf(\"\\\\Noselect\")>=0){\n                    this._mailboxList[j].disabled = true;\n                }\n\n                if(curXinfo.tags.indexOf(\"\\\\Inbox\")>=0){\n                    this._mailboxList[j].type = \"Inbox\";\n                }else if(curXinfo.tags.indexOf(\"\\\\All\")>=0 || curXinfo.tags.indexOf(\"\\\\AllMail\")>=0){\n                    this._mailboxList[j].type = \"All Mail\";\n                }else if(curXinfo.tags.indexOf(\"\\\\Archive\")>=0){\n                    this._mailboxList[j].type = \"Archive\";\n                }else if(curXinfo.tags.indexOf(\"\\\\Drafts\")>=0){\n                    this._mailboxList[j].type = \"Drafts\";\n                }else if(curXinfo.tags.indexOf(\"\\\\Sent\")>=0){\n                    this._mailboxList[j].type = \"Sent\";\n                }else if(curXinfo.tags.indexOf(\"\\\\Junk\")>=0 || curXinfo.tags.indexOf(\"\\\\Spam\")>=0){\n                    this._mailboxList[j].type = \"Junk\";\n                }else if(curXinfo.tags.indexOf(\"\\\\Flagged\")>=0 || curXinfo.tags.indexOf(\"\\\\Starred\")>=0){\n                    this._mailboxList[j].type = \"Flagged\";\n                }else if(curXinfo.tags.indexOf(\"\\\\Important\")>=0){\n                    this._mailboxList[j].type = \"Important\";\n                }else if(curXinfo.tags.indexOf(\"\\\\Trash\")>=0){\n                    this._mailboxList[j].type = \"Trash\";\n                }\n\n                break;\n            }\n        }\n    }\n\n    if(typeof callback == \"function\"){\n        callback(null, this._mailboxList);\n    }\n};\n\n/**\n * Handle SELECT and EXAMINE commands. If succeeded, move to SELECTED state.\n * If callback is set runs it with selected mailbox data\n *\n *\n * @param {Function} callback Callback function to run on completion\n * @param {String} status If \"OK\" then the command succeeded\n * @params {Array} params Parsed params excluding tag and SELECT\n */\nIMAPClient.prototype._handlerTaggedSelect = function(callback, status, params){\n    if(status == \"OK\"){\n        this._currentState = this.states.SELECTED;\n\n        if(Array.isArray(params) && params[0] && params[0].params){\n            if(params[0].params[0] == \"READ-WRITE\"){\n                this._selectedMailbox.readOnly = false;\n            }else if(params[0].params[0] == \"READ-ONLY\"){\n                this._selectedMailbox.readOnly = true;\n            }\n        }\n\n        clearTimeout(this._shouldIdleTimer);\n        clearTimeout(this._idleTimer);\n        this._shouldIdleTimer = setTimeout(this.idle.bind(this), this.ENTER_IDLE);\n\n        if(typeof callback == \"function\"){\n            callback(null, this._selectedMailbox);\n        }else{\n            this.emit(\"mailbox\", this._selectedMailbox);\n        }\n    }else{\n        var error = new Error(\"Mailbox select failed\");\n        error.errorType = \"MailboxError\";\n        error.errorLog = this._log.slice(0, this._logLength);\n        if(typeof callback == \"function\"){\n            callback(error);\n        }else{\n            this.emit(\"error\", error);\n        }\n    }\n};\n\n\n// HANDLERS FOR UNTAGGED RESPONSES\n\n/**\n * Handle untagged CAPABILITY response, store params to _capabilities array\n *\n * @param {Array} list Params for \"* CAPABILITY\" as an array\n */\nIMAPClient.prototype._handlerUntaggedCapability = function(list){\n    this._updatedCapabilities = true;\n    this._capabilities = list;\n};\n\n/**\n * Handle untagged ID response.\n *\n * @param {Array} list Params\n */\nIMAPClient.prototype._handlerUntaggedId = function(list){\n    list = (list || [])[0] || [];\n    var key;\n    for(var i=0, len = list.length; i<len; i++){\n        if(i % 2 === 0){\n            key = list[i];\n        }else{\n            this._serverId[key] = list[i];\n        }\n    }\n};\n\n/**\n * Handle untagged ENABLED response.\n *\n * @param {Array} list Params\n */\nIMAPClient.prototype._handlerUntaggedEnabled = function(list){\n    list = [].concat(list || []);\n\n    if(list[0] == \"CONDSTORE\"){\n        this._condstoreEnabled = true;\n    }\n\n};\n\n/**\n * Handle untagged SPECIAL-USE LIST and XLIST responses, for mailbox data.\n * Store mailbox info into _mailboxList property.\n *\n * @param {Array} list Params for LIST\n */\nIMAPClient.prototype._handlerUntaggedList = function(list){\n    var tags = list.shift() || [],\n        delimiter = list.shift() || this._mailboxDelimiter,\n        path = (list.shift() || \"\").substr(this._rootPath.length),\n        name = delimiter?path.split(delimiter).pop():path,\n        mailbox = {\n            name: this._convertFromUTF7(name),\n            delimiter: delimiter,\n            path: path,\n            tags: tags\n        };\n\n    this._mailboxDelimiter = delimiter;\n\n    this._mailboxList.push(mailbox);\n};\n\n/**\n * Handle untagged LSUB responses, for mailbox data. Store mailbox\n * info into _mailboxList property.\n *\n * @param {Array} list Params for LIST\n */\nIMAPClient.prototype._handlerUntaggedLsub = function(list){\n    var tags = list.shift() || [],\n        delimiter = list.shift() || this._mailboxDelimiter,\n        path = (list.shift() || \"\").substr(this._rootPath.length),\n        name = delimiter?path.split(delimiter).pop():path,\n        mailbox = new Mailbox({\n            client: this,\n            path: path,\n            name: this._convertFromUTF7(name),\n            delimiter: delimiter\n        });\n\n    if(tags.indexOf(\"\\\\HasChildren\")>=0){\n        mailbox.hasChildren = true;\n    }\n\n    if(name == \"INBOX\"){\n        mailbox.type=\"Inbox\";\n    }\n\n    this._mailboxList.push(mailbox);\n};\n\n/**\n * Handle untagged IDLE, this means that idle mode has been entered.\n */\nIMAPClient.prototype._handlerUntaggedIdle = function(){\n    this._idleWait = false;\n    this.idling = true;\n    if(this._shouldCheckOnIdle){\n        this._shouldCheckOnIdle = false;\n        this._checkNewMail();\n    }\n    this._processCommandQueue();\n};\n\n/**\n * Handle untagged FETCH responses, these have data about individual messages.\n *\n * @param {Array} list Params about a message\n */\nIMAPClient.prototype._handlerUntaggedFetch = function(list){\n    var envelope = (list || [])[3] || [],\n        envelopeData = this._formatEnvelope(envelope),\n        nextUID = Number(this._selectedMailbox.UIDNext) || 0,\n        currentUID = Number(envelopeData.UID) || 0;\n\n    if(!nextUID || nextUID <= currentUID){\n        this._selectedMailbox.UIDNext = currentUID + 1;\n    }\n\n    if(this._collectMailList){\n        this._mailList.push(envelopeData);\n    }\n\n    // emit as new message\n    if(nextUID && nextUID <= currentUID && this._checkForNewMail){\n        this.emit(\"new\", envelopeData);\n    }\n};\n\n/**\n * Handle untagged SERACH responses, this is a list of seq or uid values\n *\n * @param {Array} list Params about a message\n */\nIMAPClient.prototype._handlerUntaggedSearch = function(list){\n    if(this._collectMailList){\n        this._mailList = this._mailList.concat(list.map(Number));\n    }\n};\n\n/**\n * Timeout function for idle mode - if sufficient time has passed, break the\n * idle and run NOOP. After this, re-enter IDLE\n */\nIMAPClient.prototype._idleTimeout = function(){\n    this._send(\"NOOP\", this.idle.bind(this));\n};\n\n// STATE RELATED HANDLERS\n\n/**\n * Run after CAPABILITY response is received. If in PREAUTH state, initiate login,\n * if in AUTH mode, run _postAuth\n */\nIMAPClient.prototype._postCapability = function(){\n    if(this._currentState == this.states.PREAUTH){\n        this._updatedCapabilities = false;\n\n        if(this._capabilities.indexOf(\"AUTH=XOAUTH2\")>=0 && this._xoauth2){\n            this._xoauth2.getToken((function(err, token){\n                var error;\n\n                if(err){\n                    if(typeof err != \"object\"){\n                        error = new Error(err.toString());\n                    }else{\n                       error = err;\n                    }\n                    error.errorType = \"AuthenticationError\";\n                    error.errorLog = this._log.slice(0, this._logLength);\n                    this.emit(\"error\", error);\n                    return;\n                }\n                this._send(\"AUTHENTICATE XOAUTH2 \" + token,\n                     this._handlerTaggedLogin.bind(this), (function(){\n                        this._xoauth2UntaggedResponse = false;\n                        this._literalHandler = (function(message){\n\n                            this._xoauth2UntaggedResponse = true;\n\n                            message = (Array.isArray(message) && message[0] || message || \"\").toString().trim();\n                            var data;\n                            try{\n                                data = JSON.parse(new Buffer(message, \"base64\").toString(\"utf-8\"));\n                            }catch(E){\n                                data = {\n                                    status: 500,\n                                    error: E.message\n                                };\n                            }\n\n                            if(['400', '401'].indexOf((data.status || \"\").toString().trim())>=0){\n                                this._xoauth2RetryCount = (this._xoauth2RetryCount || 0) + 1;\n                            }\n\n                            this._connection.write(\"\\r\\n\");\n                            if(this.debug){\n                                console.log(\"CLIENT:\");\n                            }\n                        }).bind(this);\n                     }).bind(this));\n            }).bind(this));\n        }else if(this._capabilities.indexOf(\"AUTH=XOAUTH\")>=0 && this.options.auth.XOAuthToken){\n            if(typeof this.options.auth.XOAuthToken == \"object\"){\n                this._send(\"AUTHENTICATE XOAUTH \" + this.options.auth.XOAuthToken.generate(),\n                     this._handlerTaggedLogin.bind(this));\n            }else{\n                this._send(\"AUTHENTICATE XOAUTH \"+(this.options.auth.XOAuthToken || \"\").toString(),\n                     this._handlerTaggedLogin.bind(this));\n            }\n        }else{\n            this._send(\"LOGIN \"+this._escapeString(this.options.auth.user)+\" \"+\n                this._escapeString(this.options.auth.pass), this._handlerTaggedLogin.bind(this));\n        }\n    }else if(this._currentState == this.states.AUTH){\n        this._postAuth();\n    }else{\n        throw new Error(\"Unhandled event state\");\n    }\n};\n\n/**\n * Run when user is successfully entered AUTH state\n */\nIMAPClient.prototype._postAuth = function(){\n    if(this._capabilities.indexOf(\"CONDSTORE\")>=0){\n        this._send(\"ENABLE CONDSTORE\", this._handlerTaggedCondstore.bind(this));\n    }else{\n        this._handlerTaggedCondstore(\"OK\");\n    }\n};\n\n/**\n * Run it when all the required jobs for setting up an authorized connection\n * are completed. Emit 'connect' event.\n *\n * @param {Object} err Error object, if an error appeared\n */\nIMAPClient.prototype._postReady = function(err){\n    if(err){\n        this.emit(\"error\", err);\n    }else{\n        this.emit(\"connect\");\n    }\n};\n\n// HELPER FUNNCTIONS\n\n/**\n * Escapes a string and encloses it with double quotes.\n *\n * @param {String} str String to escape\n */\nIMAPClient.prototype._escapeString = function(str){\n    return \"\\\"\" + (str || \"\").toString().replace(/([\"\\\\])/g, \"\\\\$1\").replace(/[\\r\\n]/g, \" \") + \"\\\"\";\n};\n\n/**\n * Format envelope object from (FLAGS ENVELOPE) response object\n *\n * @param {Array} envelopeData An array with FLAGS and ENVELOPE response data\n * @return {Object} structured envelope data\n */\nIMAPClient.prototype._formatEnvelope = function(envelopeData){\n\n    if(!Array.isArray(envelopeData)){\n        return null;\n    }\n\n    var dataObject = {}, lastKey = false, i, len;\n\n    for(i=0, len = envelopeData.length; i<len; i++){\n        if(!lastKey){\n            lastKey = (envelopeData[i] && envelopeData[i].value || envelopeData[i] || \"\").toString();\n        }else{\n            dataObject[lastKey] = envelopeData[i];\n            lastKey = false;\n        }\n    }\n\n    var message = {\n        UIDValidity: this._selectedMailbox.UIDValidity,\n        path: this._selectedMailbox.path\n    };\n\n    if(dataObject.UID){\n        message.UID = Number(dataObject.UID) || 0;\n    }\n\n    if(dataObject.FLAGS){\n        message.flags = dataObject.FLAGS || [];\n    }\n\n    if(dataObject.INTERNALDATE){\n        message.internalDate = new Date(dataObject.INTERNALDATE || Date.now());\n    }\n\n    if(dataObject[\"X-GM-THRID\"]){\n        message.xGMThreadId = dataObject[\"X-GM-THRID\"];\n    }\n\n    if(dataObject.MODSEQ){\n        message.modSeq = Number(dataObject.MODSEQ);\n    }\n\n    if (dataObject[\"RFC822.HEADER\"]){\n\n        var startIndex = dataObject[\"RFC822.HEADER\"].indexOf('References:') + 'References:'.length;\n        if (startIndex != -1){\n            var endIndex = dataObject[\"RFC822.HEADER\"].indexOf(':', startIndex);\n            message.references = dataObject[\"RFC822.HEADER\"].substring(startIndex, endIndex).match(/<(.*?)>+/igm);\n        }\n        \n        var temp = dataObject[\"RFC822.HEADER\"].match(/(X-Originating-IP:).+?]/igm)\n        if (temp){\n            message.xOriginatingIP = temp[0].substring('X-Originating-IP:'.length).trim().replace(/(\\[|\\])/g, '');\n        }\n    }\n\n    if(dataObject.BODYSTRUCTURE){\n        message.bodystructure = this._parseBodystructure(dataObject.BODYSTRUCTURE);\n    }\n\n    var messageTypes = [],\n        messageTypeMap = {\n            \"Drafts\": \"Draft\",\n            \"Flagged\": \"Starred\",\n            \"Spam\": \"Junk\"\n        },\n        messageTypePreferenceOrder = [\"Sent\", \"Draft\", \"Starred\", \"Junk\", \"Trash\"];\n\n    if(dataObject[\"X-GM-LABELS\"]){\n        message.labels = [].concat(dataObject[\"X-GM-LABELS\"] || []);\n        message.folders = (dataObject[\"X-GM-LABELS\"] || []).map((function(label){\n            var type;\n\n            if(label && typeof label == \"object\" && label.params){\n                label = label.params.map((function(localLabel){\n                    localLabel = this._convertFromUTF7(localLabel || \"\");\n                    messageTypes.push(localLabel);\n                    return localLabel;\n                }).bind(this)).join(this._mailboxDelimiter);\n            }\n\n            label = this._convertFromUTF7(label || \"\");\n\n            // trim delimiters\n            if(label.charAt(0) == this._mailboxDelimiter){\n                label = label.substr(1);\n            }\n            if(label.charAt(label.length-1) == this._mailboxDelimiter){\n                label = label.substr(0, label.length-1);\n            }\n\n            if(label.search(this._mailboxDelimiter) > 0){ // ignore the first char\n                return label.split(this._mailboxDelimiter).map(function(localLabel){\n                    var localType;\n                    if((localType = detectMailboxType(localLabel)) != \"Normal\"){\n                        messageTypes.push(localType);\n                        return localLabel;\n                    }else{\n                        return localLabel;\n                    }\n                });\n            }\n\n            // Convert name to canonized version\n            if((type = detectMailboxType(label)) != \"Normal\"){\n                // Add flag indicator\n                messageTypes.push(type);\n                return type;\n            }\n\n            // Convert tags to names\n            if(label.charAt(0)==\"\\\\\" && label != \"\\\\Important\"){\n                label = label.substr(1);\n                messageTypes.push(label);\n            }\n\n            return label;\n        }).bind(this));\n    }else{\n        message.folders = (this._selectedMailbox.path || \"\").split(this._mailboxDelimiter) || [];\n        if(message.folders.length > 1){\n            message.folders = [message.folders];\n        }else if(message.folders.length){\n            message.folders = [message.folders[0]];\n        }\n\n        if(message.folders.length){\n            [].concat(message.folders[0]).forEach((function(localLabel){\n                var type;\n                if((type = detectMailboxType(localLabel)) != \"Normal\"){\n                    // Add flag indicator\n                    messageTypes.push(type);\n                }\n            }).bind(this));\n        }\n    }\n\n    // remove duplicates\n    if(message.folders){\n        var folderList = [];\n        for(i=0, len=message.folders.length; i<len; i++){\n            if((folderList.indexOf(message.folders[i]) < 0) && (message.folders[i] != \"\\\\Important\")){\n                folderList.push(message.folders[i]);\n            }\n        }\n        message.folders = folderList;\n\n        if(!dataObject[\"X-GM-LABELS\"] && !message.folders.length){\n            message.folders = [\"Inbox\"];\n        }\n    }\n\n    messageTypes = messageTypes.map(function(type){\n        return messageTypeMap[type] || type;\n    });\n\n    messageTypes.sort(function(a, b){\n        a = messageTypePreferenceOrder.indexOf(a);\n        b = messageTypePreferenceOrder.indexOf(b);\n        if(a<0){\n            return 1;\n        }\n        if(b<0){\n            return -1;\n        }\n        return a - b;\n    });\n\n    message.type = messageTypes.length && messageTypePreferenceOrder.indexOf(messageTypes[0])>=0 && messageTypes[0] || \"Normal\";\n    if(message.type == \"Normal\" && message.flags && message.flags.indexOf(\"\\\\Flagged\")>=0){\n        message.type = \"Starred\";\n    }\n\n    if(dataObject.ENVELOPE){\n        message.date = new Date(dataObject.ENVELOPE[0] || Date.now());\n\n        message.title = (dataObject.ENVELOPE[1] || \"\").toString().\n            replace(/\\=\\?[^?]+\\?[QqBb]\\?[^?]*\\?=/g,\n                function(mimeWord){\n                    return mimelib.decodeMimeWord(mimeWord);\n                });\n\n        if(dataObject.ENVELOPE[2] && dataObject.ENVELOPE[2].length){\n            message.from = [].concat(dataObject.ENVELOPE[2] || []).map(this._formatEnvelopeAddress);\n            if(message.from.length == 1){\n                message.from = message.from[0];\n            }\n        }\n\n        if(dataObject.ENVELOPE[5] && dataObject.ENVELOPE[5].length){\n            message.to = [].concat(dataObject.ENVELOPE[5] || []).map(this._formatEnvelopeAddress);\n        }\n        if(dataObject.ENVELOPE[6] && dataObject.ENVELOPE[6].length){\n            message.cc = [].concat(dataObject.ENVELOPE[6] || []).map(this._formatEnvelopeAddress);\n        }\n\n        if(dataObject.ENVELOPE[8] && dataObject.ENVELOPE[8].length){\n            message.inReplyTo = (dataObject.ENVELOPE[8] || \"\").toString().replace(/\\s/g,\"\");\n        }\n\n        message.messageId = (dataObject.ENVELOPE[9] || \"\").toString().toString().replace(/\\s/g,\"\");\n    }\n\n    return message;\n};\n\n/**\n * Formats an IMAP ENVELOPE address in simpler {name, address} format\n *\n * @param {Array} address IMAP ENVELOPE address array [name, smtp route, user, domain]\n * @return {Object} simple {name, address} format\n */\nIMAPClient.prototype._formatEnvelopeAddress = function(address){\n    address = [].concat(address || []);\n    var name = address[0] ||\"\",\n        email = (address[2] || \"\") + \"@\" + (address[3] || \"\");\n\n    if(email == \"@\"){\n        email = \"\";\n    }\n\n    return {\n        name: (name || email).replace(/\\=\\?[^?]+\\?[QqBb]\\?[^?]*\\?=/g,\n                function(mimeWord){\n                    return mimelib.decodeMimeWord(mimeWord);\n                }),\n        address: email\n    };\n};\n\n/**\n * Parses bodystructure of an IMAP message according to http://tools.ietf.org/html/rfc3501#section-7.4.2\n * parsed bodystructures will look something like this\n * {\n *     'type': 'multipart/mixed',\n *     1: {\n *         'type': 'multipart/alternative',\n *         1: {\n *             'type': 'text/plain',\n *             params: {\n *                 'charset': 'utf-8'\n *             },\n *             encoding: '7bit',\n *             size: 50,\n *             lines: 10,\n *         },\n *         2: {\n *             'type': 'text/html',\n *             params: {\n *                 'charset': 'utf-8'\n *             },\n *             encoding: '7bit',\n *             size: 158,\n *         }\n *     },\n *     2: {\n *         'type': 'application/octet-stream',\n *         params: {\n *             'name': 'foobar.md'\n *         },\n *         encoding: 'base64',\n *         size: 286,\n *         disposition: [{\n *             'attachment': {\n *                 'filename': 'foobar.md'\n *             }\n *         }]\n *     }\n * }\n *\n * @param {Array} bs Array containing the raw bodystructure array\n * @return {Object} Parsed bodystructure, see comment below\n */\nIMAPClient.prototype._parseBodystructure = function(bs, parentBodypart) {\n    var self = this;\n\n    if (typeof bs === 'string') {\n        // type information for multipart/alternative or multipart/mixed\n        return 'multipart/' + bs.toLowerCase();\n    }\n\n    if (!Array.isArray(bs)) {\n        // if it is not the information on which type of multipart/*\n        // we've got here, or an array containing valuable information,\n        // it is just imap noise\n        return;\n    }\n\n    if (!Array.isArray(bs[0]) && typeof bs[0] === 'string' && bs.length >= 10) {\n        // we've got a single part, usually a text/plain, text/html or attachment part\n        var dispositionIndex = 8,\n            currentPart = {}, type, subtype;\n\n        currentPart.part = parentBodypart || '1';\n        type = bs[0].toLowerCase();\n        subtype = bs[1].toLowerCase();\n        currentPart.type = type + '/' + subtype;\n        currentPart.parameters = {};\n        if (bs[2]) {\n            // the parameters are a key/value list\n            var parametersIndex = 0;\n            while(parametersIndex < bs[2].length) {\n                currentPart.parameters[bs[2][parametersIndex].toLowerCase()] = bs[2][parametersIndex + 1].toLowerCase();\n                parametersIndex += 2;\n            }\n        }\n        currentPart.encoding = bs[5].toLowerCase();\n        currentPart.size = parseInt(bs[6], 10);\n\n        if (type === 'message' && subtype === 'rfc822') {\n            // parsing of envelope and body structure information for message/rfc882 mails is not supported,\n            // because there are IMAP servers which violate rfc 3501 for message/rfc882, for example gmail.\n            return currentPart;\n        }\n\n        if (type === 'text') {\n            // text/* body parts have an additional field for the body size in lines in its content transfer encoding.\n            currentPart.lines = parseInt(bs[7], 10);\n            dispositionIndex = 9;\n        }\n\n        if (bs[dispositionIndex]) {\n            currentPart.disposition = [];\n            if (Array.isArray(bs[dispositionIndex][0])) {\n                bs[dispositionIndex].forEach(function(rawAttachment){\n                    if (!rawAttachment) {\n                        return;\n                    }\n\n                    currentPart.disposition.push(parseAttachment(rawAttachment));\n                });\n            } else {\n                currentPart.disposition.push(parseAttachment(bs[dispositionIndex]));\n            }\n        }\n\n        return currentPart;\n    }\n\n    if (Array.isArray(bs[0])) {\n        // we have got a multipart/* message\n        var bodypartsCounter = 1, parsedBodystructure = {},\n            parsedPart, partIdentifier;\n\n        bs.forEach(function(rawPart) {\n            partIdentifier = (parentBodypart ? (parentBodypart + '.') : '') + bodypartsCounter;\n            parsedPart = self._parseBodystructure(rawPart, partIdentifier);\n            if (typeof parsedPart === 'string') {\n                parsedBodystructure.type = parsedPart;\n            } else if (typeof parsedPart === 'object') {\n                parsedBodystructure[bodypartsCounter] = parsedPart;\n                bodypartsCounter++;\n            }\n        });\n\n        return parsedBodystructure;\n    }\n\n    // helper function to parse attachments\n    function parseAttachment(rawAttachment) {\n        var parsedAttachment = {};\n\n        parsedAttachment.type = rawAttachment[0].toLowerCase();\n        if (rawAttachment[1]) {\n            // attachment filename, not present in inline attachments\n            parsedAttachment[rawAttachment[1][0].toLowerCase()] = rawAttachment[1][1];\n        }\n\n        return parsedAttachment;\n    }\n};\n\n/**\n * Convert from IMAP UTF7 to UTF-8 - useful for mailbox names\n */\nIMAPClient.prototype._convertFromUTF7 = function(str){\n    return utf7.decode((str || \"\").toString());\n};\n\n/**\n * Check for new mail, since the last known UID\n */\nIMAPClient.prototype._checkNewMail = function(){\n    if(isNaN(this._selectedMailbox.UIDNext)){\n        return;\n    }\n\n    this._send(\"UID FETCH \" + this._selectedMailbox.UIDNext + \":* (UID BODYSTRUCTURE FLAGS ENVELOPE INTERNALDATE\" +\n      (this._capabilities.indexOf(\"X-GM-EXT-1\") >= 0 ? \" X-GM-LABELS X-GM-THRID\" : \"\") +\n      (this._capabilities.indexOf(\"CONDSTORE\") >= 0 ? \" MODSEQ\" : \"\") +\n      \")\", (function(){\n        this._checkForNewMail = false;\n    }).bind(this),\n    (function(){\n        this._checkForNewMail = true;\n    }).bind(this));\n};\n\n// PUBLIC API\n\n/**\n * Lists root mailboxes\n *\n * @param {Function} callback Callback function to run with the mailbox list\n */\nIMAPClient.prototype.listMailboxes = function(path, all, callback){\n    this._rootMailbox.listChildren(path, all, callback);\n};\n\n/**\n * Opens a selected mailbox. This is needed before you can open any message.\n *\n * @param {String} path Mailbox full path, ie \"INBOX/Sent Items\"\n * @param {Object} [options] Optional options object\n * @param {Boolean} [options.readOnly] If set to true, open the mailbox in read-only mode (seen/unseen flags won't be touched)\n * @param {Function} callback Callback function to run when the mailbox is opened\n */\nIMAPClient.prototype.openMailbox = function(path, options, callback){\n    var command = \"SELECT\";\n\n    if(typeof options == \"function\" && !callback){\n        callback = options;\n        options = undefined;\n    }\n\n    options = options || {};\n\n    if(options.readOnly){\n        command = \"EXAMINE\";\n    }\n\n    if(typeof path == \"object\"){\n        path = path.path;\n    }\n\n    if(!path){\n        return callback(new Error(\"Invalid or missing mailbox path provided\"));\n    }\n\n    this._selectedMailbox = {\n        path: path\n    };\n\n    this._send(command + \" \" + this._escapeString(path)+(\n        this._condstoreEnabled?\" (CONDSTORE)\":\"\"\n      ), this._handlerTaggedSelect.bind(this, callback));\n};\n\n/**\n * Returns the current mailbox data object\n *\n * @return {Object} Information about currently selected mailbox\n */\nIMAPClient.prototype.getCurrentMailbox = function(){\n    return this._selectedMailbox;\n};\n\n/**\n * Lists message envelopes for selected range. Negative numbers can be used to\n * count from the end of the list (most recent messages).\n *\n * @param {Number} from List from position (0 based)\n * @param {Number} limit How many messages to fetch, defaults to all from selected position\n * @param {String} [extendedOptions] Additional string to add to the FETCH query\n * @param {Function} callback Callback function to run with the listed envelopes\n */\nIMAPClient.prototype.listMessages = function(from, limit, extendedOptions, callback){\n    var to;\n\n    from = Number(from) || 0;\n\n    if(typeof extendedOptions == \"function\" && !callback){\n        callback = extendedOptions;\n        extendedOptions = undefined;\n    }\n\n    if(typeof limit == \"function\" && !callback){\n        callback = limit;\n        limit = undefined;\n    }\n\n    extendedOptions = extendedOptions || \"\";\n    limit = Number(limit) || 0;\n\n    if(this._currentState != this.states.SELECTED){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"No mailbox selected\"));\n        }\n        return;\n    }\n\n    // Nothing to retrieve\n    if(!this._selectedMailbox.count){\n        return callback(null, []);\n    }\n\n    if(from < 0){\n        from = this._selectedMailbox.count + from;\n    }\n\n    if(from < 0){\n        from = 0;\n    }\n\n    if(limit){\n        to = from + limit;\n    }else{\n        to = \"*\";\n    }\n\n    from++;\n\n    this._collectMailList = true;\n    this._mailList = [];\n\n    this._send(\n      \"FETCH \" + from + \":\" + to +\n      \" (UID BODYSTRUCTURE FLAGS ENVELOPE INTERNALDATE RFC822.HEADER\" +\n      (this._capabilities.indexOf(\"X-GM-EXT-1\")>=0?\" X-GM-LABELS X-GM-THRID\":\"\") +\n      (this._capabilities.indexOf(\"CONDSTORE\") >= 0 ? \" MODSEQ\" : \"\") +\n      \")\" +\n      (extendedOptions ? \" \"+extendedOptions : \"\"), (function(status){\n        this._collectMailList = false;\n\n        if(typeof callback != \"function\"){\n            return;\n        }\n\n        if(status == \"OK\"){\n            callback(null, this._mailList);\n        }else{\n            callback(new Error(\"Error fetching list\"));\n        }\n    }).bind(this));\n};\n\n/**\n * Lists message envelopes for selected range. Similar to listMessages but uses UID values\n *\n * @param {Number} from First UID value\n * @param {Number} to Last UID value or \"*\"\n * @param {String} [extendedOptions] Additional string to add to the FETCH query\n * @param {Function} callback Callback function to run with the listed envelopes\n */\nIMAPClient.prototype.listMessagesByUID = function(from, to, extendedOptions, callback){\n    from = Number(from) || 0;\n\n    if(typeof extendedOptions == \"function\" && !callback){\n        callback = extendedOptions;\n        extendedOptions = undefined;\n    }\n\n    if(typeof to == \"function\" && !callback){\n        callback = to;\n        to = undefined;\n    }\n\n    extendedOptions = extendedOptions || \"\";\n    to = Number(to) || \"*\";\n\n    if(this._currentState != this.states.SELECTED){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"No mailbox selected\"));\n        }\n        return;\n    }\n\n    // Nothing to retrieve\n    if(!this._selectedMailbox.count){\n        return callback(null, []);\n    }\n\n    this._collectMailList = true;\n    this._mailList = [];\n\n    this._send(\n      \"UID FETCH \" + from + \":\" + to +\n      \" (UID BODYSTRUCTURE FLAGS ENVELOPE INTERNALDATE RFC822.HEADER\" +\n      (this._capabilities.indexOf(\"X-GM-EXT-1\")>=0?\" X-GM-LABELS X-GM-THRID\":\"\") +\n      (this._capabilities.indexOf(\"CONDSTORE\") >= 0 ? \" MODSEQ\" : \"\") +\n      \")\" +\n      (extendedOptions ? \" \"+extendedOptions : \"\"), (function(status){\n        this._collectMailList = false;\n\n        if(typeof callback != \"function\"){\n            return;\n        }\n\n        if(status == \"OK\"){\n            callback(null, this._mailList);\n        }else{\n            callback(new Error(\"Error fetching list\"));\n        }\n    }).bind(this));\n};\n\n/**\n * Lists flags for selected range. Negative numbers can be used to\n * count from the end of the list (most recent messages).\n *\n * @param {Number} from List from position (0 based)\n * @param {Number} limit How many messages to fetch, defaults to all from selected position\n * @param {Function} callback Callback function to run with the listed envelopes\n */\nIMAPClient.prototype.listFlags = function(from, limit, callback){\n    var to;\n\n    from = Number(from) || 0;\n\n    if(typeof limit == \"function\" && !callback){\n        callback = limit;\n        limit = undefined;\n    }\n\n    limit = Number(limit) || 0;\n\n    if(this._currentState != this.states.SELECTED){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"No mailbox selected\"));\n        }\n        return;\n    }\n\n    if(from < 0){\n        from = this._selectedMailbox.count + from;\n    }\n\n    if(from < 0){\n        from = 0;\n    }\n\n    if(limit){\n        to = from + limit;\n    }else{\n        to = \"*\";\n    }\n\n    from++;\n\n    this._collectMailList = true;\n    this._mailList = [];\n    this._send(\"FETCH \" + from + \":\" + to + \" (UID FLAGS)\", (function(status){\n        this._collectMailList = false;\n\n        if(typeof callback != \"function\"){\n            return;\n        }\n\n        if(status == \"OK\"){\n            callback(null, this._mailList);\n        }else{\n            callback(new Error(\"Error fetching list\"));\n        }\n    }).bind(this));\n};\n\n/**\n * Updates flags for selected message\n *\n * @param {String} uid Message identifier\n * @param {Array} flags Flags to set for a message\n * @param {String} [updateType=\"\"] If empty, replace flags; + add flag; - remove flag\n * @param {Function} callback Callback function to run, returns an array of flags\n */\nIMAPClient.prototype.updateFlags = function(uid, flags, updateType, callback){\n    flags = [].concat(flags || []);\n\n    if(!callback && typeof updateType == \"function\"){\n        callback = updateType;\n        updateType = undefined;\n    }\n\n    updateType = (updateType || \"\").toString().trim();\n\n    if(!uid){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Invalid UID value\"));\n        }\n        return;\n    }\n\n    if(!Array.isArray(flags)){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Invalid flags value\"));\n        }\n        return;\n    }\n\n    if(this._currentState != this.states.SELECTED){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"No mailbox selected\"));\n        }\n        return;\n    }\n\n    this._send(\"UID STORE \"+uid+\" \"+updateType+\"FLAGS (\" + flags.join(\" \") + \")\",\n      (function(status){\n        this._collectMailList = false;\n\n        if(typeof callback != \"function\"){\n            return;\n        }\n\n        if(typeof callback == \"function\"){\n            if(status == \"OK\"){\n                if(!this._mailList.length){\n                    callback(null, true);\n                }else{\n                    callback(null, this._mailList[0].flags || []);\n                }\n            }else{\n                callback(new Error(\"Error setting flags\"));\n            }\n        }\n\n    }).bind(this),\n    (function(){\n        this._collectMailList = true;\n        this._mailList = [];\n    }).bind(this));\n};\n\n/**\n * Add flags for selected message\n *\n * @param {String} uid Message identifier\n * @param {Array} flags Flags to set for a message\n * @param {Function} callback Callback function to run, returns an array of flags\n */\nIMAPClient.prototype.addFlags = function(uid, flags, callback){\n    flags = [].concat(flags || []);\n    this.updateFlags(uid, flags, \"+\", callback);\n};\n\n/**\n * Removes flags for selected message\n *\n * @param {String} uid Message identifier\n * @param {Array} flags Flags to remove from a message\n * @param {Function} callback Callback function to run, returns an array of flags\n */\nIMAPClient.prototype.removeFlags = function(uid, flags, callback){\n    flags = [].concat(flags || []);\n    this.updateFlags(uid, flags, \"-\", callback);\n};\n\n/**\n * Updates labels for selected message\n *\n * @param {String} uid Message identifier\n * @param {Array} labels Labels to set for a message\n * @param {String} [updateType=\"\"] If empty, replace labels; + add label; - remove label\n * @param {Function} callback Callback function to run, returns an array of labels\n */\nIMAPClient.prototype.updateLabels = function(uid, labels, updateType, callback){\n    labels = [].concat(labels || []);\n\n    if(!callback && typeof updateType == \"function\"){\n        callback = updateType;\n        updateType = undefined;\n    }\n\n    updateType = (updateType || \"\").toString().trim();\n\n    if(!uid){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Invalid UID value\"));\n        }\n        return;\n    }\n\n    if(!Array.isArray(labels)){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Invalid labels value\"));\n        }\n        return;\n    }\n\n    if(this._currentState != this.states.SELECTED){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"No mailbox selected\"));\n        }\n        return;\n    }\n\n    this._send(\"UID STORE \"+uid+\" \"+updateType+\"X-GM-LABELS (\" + labels.join(\" \") + \")\",\n      (function(status){\n        this._collectMailList = false;\n\n        if(typeof callback != \"function\"){\n            return;\n        }\n\n        if(typeof callback == \"function\"){\n            if(status == \"OK\"){\n                if(!this._mailList.length){\n                    callback(null, true);\n                }else{\n                    callback(null, this._mailList[0].labels || []);\n                }\n            }else{\n                callback(new Error(\"Error setting labels\"));\n            }\n        }\n\n    }).bind(this),\n    (function(){\n        this._collectMailList = true;\n        this._mailList = [];\n    }).bind(this));\n};\n\n/**\n * Add labels for selected message\n *\n * @param {String} uid Message identifier\n * @param {Array} labels Labels to set for a message\n * @param {Function} callback Callback function to run, returns an array of labels\n */\nIMAPClient.prototype.addLabels = function(uid, labels, callback){\n    labels = [].concat(labels || []);\n    this.updateLabels(uid, labels, \"+\", callback);\n};\n\n/**\n * Removes labels for selected message\n *\n * @param {String} uid Message identifier\n * @param {Array} labels Labels to remove from a message\n * @param {Function} callback Callback function to run, returns an array of labels\n */\nIMAPClient.prototype.removeLabels = function(uid, labels, callback){\n    labels = [].concat(labels || []);\n    this.updateLabels(uid, labels, \"-\", callback);\n};\n\n/**\n * Fetches flags for selected message\n *\n * @param {Number} uid Message identifier\n * @param {Function} callback Callback function to run with the flags array\n */\nIMAPClient.prototype.fetchFlags = function(uid, callback){\n    uid = Number(uid) || 0;\n\n    if(!uid){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Invalid UID value\"));\n        }\n        return;\n    }\n\n    if(this._currentState != this.states.SELECTED){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"No mailbox selected\"));\n        }\n        return;\n    }\n\n    this._send(\"UID FETCH \" + uid + \" (UID FLAGS)\", (function(status){\n        this._collectMailList = false;\n\n        if(typeof callback != \"function\"){\n            return;\n        }\n\n        if(typeof callback == \"function\"){\n            if(status == \"OK\"){\n                if(!this._mailList.length){\n                    callback(null, null);\n                }else{\n                    callback(null, this._mailList[0].flags || []);\n                }\n            }else{\n                callback(new Error(\"Error fetching message flags\"));\n            }\n        }\n\n    }).bind(this),\n    (function(){\n        this._collectMailList = true;\n        this._mailList = [];\n    }).bind(this));\n};\n\n/**\n * Fetches envelope object for selected message\n *\n * @param {Number} uid Message identifier\n * @param {Function} callback Callback function to run with the envelope object\n */\nIMAPClient.prototype.fetchData = function(uid, callback){\n    uid = Number(uid) || 0;\n\n    if(!uid){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Invalid UID value\"));\n        }\n        return;\n    }\n\n    if(this._currentState != this.states.SELECTED){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"No mailbox selected\"));\n        }\n        return;\n    }\n\n    this._send(\"UID FETCH \" + uid + \" (UID FLAGS ENVELOPE RFC822.HEADER\" +\n      (this._capabilities.indexOf(\"X-GM-EXT-1\")>=0?\" X-GM-LABELS X-GM-THRID\":\"\") +\n      (this._capabilities.indexOf(\"CONDSTORE\") >= 0 ? \" MODSEQ\" : \"\") +\n      \")\", (function(status){\n        this._collectMailList = false;\n\n        if(typeof callback != \"function\"){\n            return;\n        }\n\n        if(typeof callback == \"function\"){\n            if(status == \"OK\"){\n                if(!this._mailList.length){\n                    callback(null, null);\n                }else{\n                    callback(null, this._mailList[0]);\n                }\n            }else{\n                callback(new Error(\"Error fetching message data\"));\n            }\n        }\n\n    }).bind(this),\n    (function(){\n        this._collectMailList = true;\n        this._mailList = [];\n    }).bind(this));\n};\n\n/**\n * Creates a Readable Stream for a selected message.\n *\n * @param {Number} uid Message identifier\n */\nIMAPClient.prototype.createMessageStream = function(uid){\n    var stream = new Stream();\n\n    uid = Number(uid) || 0;\n\n    if(!uid){\n        process.nextTick(this.emit.bind(this, new Error(\"Invalid UID value\")));\n        return;\n    }\n\n    if(this._currentState != this.states.SELECTED){\n        process.nextTick(this.emit.bind(this, new Error(\"No inbox selected\")));\n        return;\n    }\n\n    this._send(\"UID FETCH \" + uid + \" BODY.PEEK[]\", (function(status){\n        this._collectMailList = false;\n        this._literalStreaming = false;\n\n        if(!this._mailList.length){\n            if(status == \"OK\"){\n                stream.emit(\"error\", new Error(\"Selected message not found: \"+uid+\"; \"+this.port+\"; \"+this.host+\"; \"+JSON.stringify(this._selectedMailbox)));\n            }else{\n                stream.emit(\"error\", new Error(\"Error fetching message: \"+uid+\"; \"+this.port+\"; \"+this.host+\"; \"+JSON.stringify(this._selectedMailbox)));\n            }\n        }\n\n        this._messageStream.emit(\"end\");\n        this._messageStream.removeAllListeners();\n\n        this._messageStream = null;\n\n    }).bind(this),\n    (function(){\n        this._collectMailList = true;\n        this._literalStreaming = true;\n        this._mailList = [];\n        this._messageStream = stream;\n    }).bind(this));\n\n    return stream;\n};\n\n/**\n * Copy message from the active mailbox to the end of destination mailbox\n *\n * @param {Number} uid Message identifier\n * @param {String} destination Destination folder to copy the message to\n * @param {Function} callback Callback function to run after the copy succeeded or failed\n */\nIMAPClient.prototype.copyMessage = function(uid, destination, callback){\n    uid = Number(uid) || 0;\n\n    if(!uid){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Invalid UID value\"));\n        }\n        return;\n    }\n\n    if(this._currentState != this.states.SELECTED){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"No mailbox selected\"));\n        }\n        return;\n    }\n\n    this._send(\"UID COPY \" + uid + \" \" + this._escapeString(destination), (function(status){\n        if(status != \"OK\"){\n            return callback(new Error(\"Error copying message\"));\n        }\n        return callback(null, true);\n    }).bind(this));\n};\n\n/**\n * Delete message from the active mailbox\n *\n * @param {Number} uid Message identifier\n * @param {Function} callback Callback function to run after the removal succeeded or failed\n */\nIMAPClient.prototype.deleteMessage = function(uid, callback){\n    uid = Number(uid) || 0;\n\n    if(!uid){\n        if(typeof callback == \"function\"){\n            callback(new Error(\"Invalid UID value\"));\n        }\n        return;\n    }\n\n    this.addFlags(uid, \"\\\\Deleted\", (function(error){\n        if(error){\n            return callback(error);\n        }\n\n        this._send(\"EXPUNGE\", (function(status){\n            if(status != \"OK\"){\n                return callback(new Error(\"Error removing message\"));\n            }\n            return callback(null, true);\n        }).bind(this));\n\n    }).bind(this));\n};\n\n/**\n * Move message from the active mailbox to the end of destination mailbox\n *\n * @param {Number} uid Message identifier\n * @param {String} destination Destination folder to move the message to\n * @param {Function} callback Callback function to run after the move succeeded or failed\n */\nIMAPClient.prototype.moveMessage = function(uid, destination, callback){\n    this.copyMessage(uid, destination, (function(error){\n        if(error){\n            return callback(error);\n        }\n        this.deleteMessage(uid, function(error){\n            // we don't really care if the removal succeeded or not at this point\n            return callback(null, !error);\n        });\n    }).bind(this));\n};\n\n/**\n * Upload a message to the mailbox\n *\n * This totally sucks but as the length of the message need to be known\n * beforehand, it is probably a good idea to include it in whole - easier\n * to implement and gives as total byte count\n */\nIMAPClient.prototype.storeMessage = function(message, flags, callback){\n    if(typeof flags == \"function\" && !callback){\n        callback = flags;\n        flags = undefined;\n    }\n\n    message = message || \"\";\n    if(typeof message == \"string\"){\n        message = new Buffer(message, \"utf-8\");\n    }\n\n    flags = [].concat(flags || []);\n    this._send(\"APPEND \" + this._escapeString(this._selectedMailbox.path) + (flags.length ? \" (\" + flags.join(\" \")+\")\":\"\") + \" {\" + message.length+\"}\", (function(status, data){\n        this._literalHandler = null;\n        if(status == \"OK\"){\n            this._shouldCheckOnIdle = true;\n\n            // supports APPENDUID\n            if(data && data[0] && data[0].params && data[0].params[0] == \"APPENDUID\"){\n                return callback(null, {\n                    UIDValidity: data[0].params[1] || \"\",\n                    UID: data[0].params[2] || \"\"\n                });\n            }\n\n            // Guess the values from mailbox data. Not sure if it really works :S\n            return callback(null, {\n                UIDValidity: this._selectedMailbox.UIDValidity,\n                UID: this._selectedMailbox.UIDNext\n            });\n        }else{\n            return callback(new Error(\"Error saving message to mailbox\"));\n        }\n    }).bind(this), (function(){\n        this._literalHandler = (function(){\n            this._connection.write(message);\n            this._connection.write(\"\\r\\n\");\n        }).bind(this);\n    }).bind(this));\n};\n\n/**\n *\n */\nIMAPClient.prototype.getMailbox = function(path, callback){\n    this._rootMailbox.listChildren(path, function(error, mailboxes){\n        if(error){\n            callback(error);\n        }else if(mailboxes && mailboxes.length){\n            callback(null, mailboxes[0]);\n        }else{\n            callback(null, null);\n        }\n    });\n};\n\n/**\n * Create a new mailbox\n */\nIMAPClient.prototype.createMailbox = function(path, callback){\n    this._rootMailbox.createChild(path, callback);\n};\n\n/**\n * Delete a mailbox\n */\nIMAPClient.prototype.deleteMailbox = function(path, callback){\n    this._rootMailbox.deleteChild(path, callback);\n};\n\n/**\n * Enter IDLE mode\n */\nIMAPClient.prototype.idle = function(){\n    if(this._capabilities.indexOf(\"IDLE\")>=0){\n        this._send(\"IDLE\", (function(){\n            this.idling = false;\n            this._idleEnd = false;\n        }).bind(this), (function(){\n            this._idleWait = true;\n            this._idleEnd = false;\n            this._idleTimer = setTimeout(this._idleTimeout.bind(this), this.IDLE_TIMEOUT);\n        }).bind(this));\n    }else{\n        if(this.debug){\n            console.log(\"WARNING: Server does not support IDLE, fallback to NOOP\");\n        }\n        this._idleTimer = setTimeout((function(){\n            this._send(\"NOOP\", (function(){\n                this.nooping = false;\n            }).bind(this), (function(){\n                this.nooping = true;\n            }).bind(this));\n        }).bind(this), this.IDLE_TIMEOUT);\n    }\n};\n\n/**\n * Lists seq or uid values for a search. Query is an object where keys are query terms and\n * values are params. Use arrays for multiple terms or true for just the key.\n *\n * connection.search({new: true, header: [\"subject\", \"test\"]}, function(err, list))\n *\n * @param {Object} Search query\n * @param {Boolean} [isUID] If true perform an UID search\n * @param {Function} callback Callback function to run with the listed envelopes\n */\nIMAPClient.prototype.search = function(query, isUid, callback){\n    if(!callback && typeof isUid == \"function\"){\n        callback = isUid;\n        isUid = undefined;\n    }\n\n    var queryType = isUid ? \"UID SEARCH\" : \"SEARCH\",\n        self = this,\n\n        buildTerm = function(query){\n            return Object.keys(query).map(function(key){\n                var term = key.toUpperCase(),\n                    params = [],\n                    escapeDate = function(date){\n                        return self._escapeString(date.toUTCString().replace(/^\\w+, (\\d+) (\\w+) (\\d+).*/, \"$1-$2-$3\"));\n                    },\n                    escapeParam = function(param){\n                        var list = [];\n                        if(typeof param == \"number\"){\n                            list.push(String(param));\n                        }else if(typeof param == \"string\"){\n                            list.push(self._escapeString(param));\n                        }else if(Object.prototype.toString.call(param) == \"[object Date]\"){\n                            list.push(escapeDate(param));\n                        }else if(Array.isArray(param)){\n                            param.map(escapeParam).forEach(function(p){\n                                if(typeof p == \"string\"){\n                                    list.push(p);\n                                }\n                            });\n                        }else if(typeof param == \"object\"){\n                            return buildTerm(param);\n                        }\n                        return list.join(\" \");\n                    };\n\n                [].concat(query[key] || []).forEach(function(param){\n                    param = escapeParam(param);\n                    if(param){\n                        params.push(param);\n                    }\n                });\n\n                return term + (params.length ? \" \" + params.join(\" \") : \"\");\n            }).join(\" \");\n        },\n\n        queryTerm = buildTerm(query);\n\n    this._collectMailList = true;\n    this._mailList = [];\n\n    this._send(queryType + (queryTerm ? \" \" + queryTerm : \"\"), (function(status){\n        this._collectMailList = false;\n\n        if(typeof callback != \"function\"){\n            return;\n        }\n\n        if(status == \"OK\"){\n            callback(null, this._mailList.sort(function(a, b){return a-b;}));\n        }else{\n            callback(new Error(\"Error searching messages\"));\n        }\n    }).bind(this));\n};\n\n/**\n * Closes the socket to the server\n * // FIXME - should LOGOUT first!\n */\nIMAPClient.prototype._close = function(){\n    if(!this._connection){\n        return;\n    }\n\n    clearTimeout(this._shouldIdleTimer);\n    clearTimeout(this._idleTimer);\n    clearTimeout(this._greetingTimeout);\n\n    var socket = this._connection.socket || this._connection;\n\n    if(socket && !socket.destroyed){\n        socket.destroy();\n    }\n\n    if(this.debug){\n        console.log(\"Connection to server closed\");\n    }\n\n    this._connection = false;\n    this._commandQueue = [];\n    this.emit(\"close\");\n\n    this.removeAllListeners();\n};\n\n// Calls LOGOUT\nIMAPClient.prototype.close = function(){\n    this._send(\"LOGOUT\", (function (){\n        this._close();\n    }).bind(this));\n};\n","/home/travis/build/npmtest/node-npmtest-inbox/node_modules/inbox/lib/starttls.js":"\"use strict\";\n\n// SOURCE: https://gist.github.com/848444\n\n// Target API:\n//\n//  var s = require('net').createStream(25, 'smtp.example.com');\n//  s.on('connect', function() {\n//   require('starttls')(s, options, function() {\n//      if (!s.authorized) {\n//        s.destroy();\n//        return;\n//      }\n//\n//      s.end(\"hello world\\n\");\n//    });\n//  });\n//\n//\n\n/**\n * @namespace Client STARTTLS module\n * @name starttls\n */\nmodule.exports.starttls = starttls;\n\n/**\n * <p>Upgrades a socket to a secure TLS connection</p>\n *\n * @memberOf starttls\n * @param {Object} socket Plaintext socket to be upgraded\n * @param {Function} callback Callback function to be run after upgrade\n */\nfunction starttls(socket, callback) {\n    var sslcontext, pair, cleartext;\n\n    socket.removeAllListeners(\"data\");\n    sslcontext = require('crypto').createCredentials();\n    pair = require('tls').createSecurePair(sslcontext, false);\n    cleartext = pipe(pair, socket);\n\n    pair.on('secure', function() {\n        var verifyError = (pair._ssl || pair.ssl).verifyError();\n\n        if (verifyError) {\n            cleartext.authorized = false;\n            cleartext.authorizationError = verifyError;\n        } else {\n            cleartext.authorized = true;\n        }\n\n        callback(cleartext);\n    });\n\n    cleartext._controlReleased = true;\n    return pair;\n}\n\nfunction forwardEvents(events, emitterSource, emitterDestination) {\n    var map = [], name, handler;\n\n    for(var i = 0, len = events.length; i < len; i++) {\n        name = events[i];\n\n        handler = forwardEvent.bind(emitterDestination, name);\n\n        map.push(name);\n        emitterSource.on(name, handler);\n    }\n\n    return map;\n}\n\nfunction forwardEvent() {\n    this.emit.apply(this, arguments);\n}\n\nfunction removeEvents(map, emitterSource) {\n    for(var i = 0, len = map.length; i < len; i++){\n        emitterSource.removeAllListeners(map[i]);\n    }\n}\n\nfunction pipe(pair, socket) {\n    pair.encrypted.pipe(socket);\n    socket.pipe(pair.encrypted);\n\n    pair.fd = socket.fd;\n\n    var cleartext = pair.cleartext;\n\n    cleartext.socket = socket;\n    cleartext.encrypted = pair.encrypted;\n    cleartext.authorized = false;\n\n    function onerror(e) {\n        if (cleartext._controlReleased) {\n            cleartext.emit('error', e);\n        }\n    }\n\n    var map = forwardEvents([\"timeout\", \"end\", \"close\", \"drain\", \"error\"], socket, cleartext);\n\n    function onclose() {\n        socket.removeListener('error', onerror);\n        socket.removeListener('close', onclose);\n        removeEvents(map,socket);\n    }\n\n    socket.on('error', onerror);\n    socket.on('close', onclose);\n\n    return cleartext;\n}\n","/home/travis/build/npmtest/node-npmtest-inbox/node_modules/inbox/lib/lineparser.js":"\"use strict\";\n\n/**\n * @fileOverview Provides a parser for IMAP line based commands\n * @author Andris Reinman\n */\n\nvar Stream = require(\"stream\").Stream,\n    utillib = require(\"util\");\n\n// expose to the world\nmodule.exports = IMAPLineParser;\n\n/**\n * Creates a reusable parser for parsing. It is a writable stream for piping\n * data directly in.\n *\n * @constructor\n */\nfunction IMAPLineParser(){\n    Stream.call(this);\n    this.writable = true;\n\n    this._init();\n}\nutillib.inherits(IMAPLineParser, Stream);\n\n/**\n * Possible states the parser can be in (Finite State Machine)\n */\nIMAPLineParser.prototype.states = {\n    DEFAULT: 0x1,\n    ATOM: 0x2,\n    QUOTED: 0x3\n};\n\n/**\n * Possible types for data nodes\n */\nIMAPLineParser.prototype.types = {\n    STRING: 0x1, // regular string, default\n    GROUP: 0x2,  // parentheses group (a b c)\n    PARAMS: 0x3, // value params BODY[PARAM1 PARAM2]\n    PARTIAL: 0x4, // Partial length indicator BODY[]<from.to>\n    LITERAL: 0x5 // {123} literal string\n};\n\n// PUBLIC METHODS\n\n/**\n * Appends a chunk for parsing\n *\n * @param {Buffer|String} chunk Data to be appended to the parse string\n * @return {Boolean} Always returns true\n */\nIMAPLineParser.prototype.write = function(chunk){\n    chunk = (chunk || \"\").toString(\"binary\");\n    this._currentLine += chunk;\n    this._parseLine(chunk);\n    return true;\n};\n\n/**\n * If a literal occurs ({123}\\r\\n) do not parse it, since the length is known.\n * Just add it separately and it will included as the node value instead of\n * length property.\n *\n * @param {Buffer|String} chunk Data to be appended to the literal string value\n */\nIMAPLineParser.prototype.writeLiteral = function(chunk){\n    if(!this.currentNode.value){\n        this.currentNode.value = \"\";\n    }\n\n    if(this.currentNode.type != this.types.LITERAL){\n        //this.currentNode.literal = this.currentNode.value;\n        this.currentNode.value = \"\";\n        //this.currentNode.type = this.types.LITERAL;\n    }\n\n    this.currentNode.value += (chunk || \"\").toString(\"binary\");\n};\n\n/**\n * Finishes current parsing and reesets internal variables. Emits 'line' event\n * with the parsed data\n *\n * @param {Buffer|String} chunk Data to be appended to the parse string\n */\nIMAPLineParser.prototype.end = function(chunk){\n    if(chunk && chunk.length){\n        this.write(chunk);\n    }\n\n    if(this.currentNode.value){\n        if(this._state == this.states.ATOM || this._state==this.states.QUOTED){\n            if(this._state == this.states.ATOM && this.currentNode.value == \"NIL\"){\n                this.currentNode.value = null;\n            }\n            this._branch.childNodes.push(this.currentNode);\n        }\n    }\n\n    process.nextTick(this.emit.bind(this, \"log\", this._currentLine));\n    process.nextTick(this.emit.bind(this, \"line\", this.finalize()));\n    this._init();\n};\n\n/**\n * Generates a structured object with the data currently known. Useful if you\n * need to check parse status in the middle of the process\n *\n * @return {Array} Parsed data\n */\nIMAPLineParser.prototype.finalize = function(){\n    var tree = [];\n    this._nodeWalker(this._parseTree.childNodes, tree);\n    return tree;\n};\n\n// PRIVATE METHODS\n\n/**\n * Resets all internal variables and creates a new parse tree\n */\nIMAPLineParser.prototype._init = function(){\n\n    /**\n     * Current state the parser is in\n     * @private\n     */\n    this._state = this.states.DEFAULT;\n\n    /**\n     * Which quote symbol is used for current quoted string\n     * @private\n     */\n    this._quoteMark = '';\n\n    /**\n     * Is the current character escaped by \\\n     * @private\n     */\n    this._escapedChar = false;\n\n    /**\n     * Parse tree to hold the parsed data structure\n     * @private\n     */\n    this._parseTree = {\n        childNodes: []\n    };\n\n    /**\n     * Active branch, by default it's the tree itselt\n     * @private\n     */\n    this._branch = this._parseTree;\n\n    /**\n     * Hold the original line data\n     * @private\n     */\n    this._currentLine = \"\";\n\n    /**\n     * Starting node\n     * @private\n     */\n    this.currentNode = {\n        parentNode: this._branch,\n        value: \"\",\n        childNodes: []\n    };\n};\n\n/**\n * Parses the data currently known, continues from the previous state.\n * This is a token based parser. Special characters are space, backslash,\n * quotes, (), [] and <>. After every character the parseTree is updated.\n *\n * @param {String} line Data to be parsed\n */\nIMAPLineParser.prototype._parseLine = function(line){\n\n    var i=0, curchar;\n\n    while(i < line.length){\n\n        curchar = line.charAt(i);\n\n        // Check all characters one by one\n        switch(curchar){\n\n            // Handle whitespace\n            case \" \":\n            case \"\\t\":\n                if(this._state == this.states.QUOTED){\n                    this.currentNode.value += curchar;\n                }else if(this._state == this.states.ATOM && this._escapedChar){\n                    this.currentNode.value += curchar;\n                }else if(this._state == this.states.ATOM){\n                    this._addToBranch();\n                    this._state = this.states.DEFAULT;\n                    this._createNode();\n                }\n                break;\n\n            // Backspace is for escaping in quoted strings\n            case '\\\\':\n                if(this._escapedChar || this._state == this.states.ATOM){\n                    this.currentNode.value += curchar;\n                }else if(this._state == this.states.QUOTED){\n                    if( line.charAt(i+1) === this._quoteMark || this._state == this.states.QUOTED){\n                        this._escapedChar = true;\n                    // This is a modified copy the default case\n                    }else if(this._state == this.states.ATOM){\n                        this.currentNode.value += curchar;\n                        this.currentNode.value += line.charAt(++i);\n                    }\n                }else if(this._state == this.states.DEFAULT){\n                    this._state = this.states.ATOM;\n                    this._createNode(curchar);\n                }\n                break;\n\n            // Handle quotes, remember the quote type to allow other unescaped quotes\n            case '\"':\n            case \"'\":\n                if(this._escapedChar || (this._state == this.states.QUOTED && this._quoteMark != curchar)){\n                    this.currentNode.value += curchar;\n                }else if(this._state == this.states.DEFAULT){\n                    this._quoteMark = curchar;\n                    this._state = this.states.QUOTED;\n                    this._createNode();\n                }else if(this._state == this.states.QUOTED){\n                    this._addToBranch();\n                    this._state = this.states.DEFAULT;\n                    this._createNode();\n                }else if(this._state == this.states.ATOM ){\n\n                    if( i === 0 || [ ' ', '\\t', '\"', \"'\", '[', '(', '<' ].indexOf( line.charAt(i-1) ) > -1 ){\n                        this._addToBranch();\n                        this._quoteMark = curchar;\n                        this._state = this.states.QUOTED;\n                        this._createNode();\n\n                    // This is a modified copy the default case\n                    }else if(this._state == this.states.ATOM || this._state == this.states.QUOTED){\n                        this.currentNode.value += curchar;\n                    }\n\n                }\n                break;\n\n            // Handle different group types\n            case \"[\":\n            case \"(\":\n            case \"<\":\n                if(this._escapedChar || this._state==this.states.QUOTED){\n                    this.currentNode.value += curchar;\n                    break;\n                }\n\n                if(this._state == this.states.ATOM){\n                    this._addToBranch();\n                }\n\n                // () gets a separate node, [] uses last node as parent\n                if(this._state == this.states.ATOM && curchar == \"[\"){\n                    this._branch = this._branch.lastNode || this._parseTree;\n                    this._branch.type = this.types.PARAMS;\n                    if(!this._branch.childNodes){\n                        this._branch.childNodes = [];\n                    }\n                }else{\n                    // create new empty node\n                    this._createNode(false);\n                    switch(curchar){\n                        case \"(\":\n                            this.currentNode.type = this.types.GROUP;\n                            break;\n                        case \"<\":\n                            this.currentNode.type = this.types.PARTIAL;\n                            break;\n                        case \"[\":\n                            this.currentNode.type = this.types.PARAMS;\n                            break;\n                    }\n\n                    this._addToBranch();\n\n                    this._branch = this.currentNode || this._parseTree;\n                    if(!this._branch.childNodes){\n                        this._branch.childNodes = [];\n                    }\n                }\n\n                this._state = this.states.DEFAULT;\n\n                this._createNode();\n\n                break;\n            case \"]\":\n            case \")\":\n            case \">\":\n                if(this._escapedChar || this._state==this.states.QUOTED){\n                    this.currentNode.value += curchar;\n                    break;\n                }\n\n                if(this._state == this.states.ATOM){\n                    this._addToBranch();\n                }\n\n                this._state = this.states.DEFAULT;\n\n                this._branch = this._branch.parentNode || this._branch;\n                if(!this._branch.childNodes){\n                    this._branch.childNodes = [];\n                }\n\n                this._createNode();\n                break;\n\n            // Add to existing string or create a new atom\n            default:\n                if(this._state == this.states.ATOM || this._state == this.states.QUOTED){\n                    this.currentNode.value += curchar;\n                }else{\n                    this._state = this.states.ATOM;\n                    this._createNode(curchar);\n                }\n        }\n\n        // cancel escape if it didn't happen\n        if(this._escapedChar && curchar != \"\\\\\"){\n            this._escapedChar = false;\n        }\n\n        i++;\n    }\n\n};\n\n/**\n * Pushes current node to the active branch\n */\nIMAPLineParser.prototype._addToBranch = function(){\n    if(this._state == this.states.ATOM && this.currentNode.value == \"NIL\"){\n        this.currentNode.value = null;\n    }\n    this._branch.childNodes.push(this.currentNode);\n    this._branch.lastNode = this.currentNode;\n};\n\n/**\n * Creates a new empty node\n *\n * @param {String} [defaultValue] If specified will be used as node.value value\n */\nIMAPLineParser.prototype._createNode = function(defaultValue){\n    this.lastNode = this.currentNode;\n\n    this.currentNode = {};\n\n    if(defaultValue !== false){\n        this.currentNode.value = defaultValue || \"\";\n    }\n\n    this.currentNode.parentNode = this._branch;\n};\n\n/**\n * Recursive function to walk the parseTree and generate structured output object\n *\n * @param {Array} branch Current branch to check\n * @param {Array} local Output object node to append the data to\n */\nIMAPLineParser.prototype._nodeWalker = function(branch, local){\n    var node, i, len, curnode, prevpos, literalLength;\n\n    for(i=0, len = branch.length; i<len; i++){\n        node = branch[i];\n\n        if((typeof node.value == \"string\" || node.value === null) && !node.type){\n            local.push(node.value);\n        }else if(node.type == this.types.LITERAL){\n\n            literalLength = node.literal.match(/\\{(\\d+)\\}/);\n            literalLength = literalLength && Number(literalLength[1]) || 0;\n\n            curnode = {\n                literal: literalLength,\n                value: node.value\n            };\n\n            local.push(curnode);\n        }else if(node.type == this.types.PARTIAL){\n            prevpos = local.length - 1;\n            if(prevpos<0){\n                curnode = {};\n            }else{\n                curnode = local[prevpos];\n                if(typeof curnode != \"object\" || Array.isArray(curnode)){\n                    curnode = {\n                        value: curnode\n                    };\n                }\n            }\n\n            local.splice(prevpos, 1, curnode);\n\n            curnode.partial = [];\n\n            if(node.childNodes.length == 1 && typeof node.childNodes[0].value == \"string\"){\n                curnode.partial = node.childNodes[0].value.split(\".\").map(Number);\n            }else{\n                this._nodeWalker(node.childNodes, curnode.partial);\n            }\n\n        }else if(node.type == this.types.PARAMS){\n            if(!node.childNodes.length){\n                local.push(node.value);\n            }else{\n                curnode = {};\n                if(typeof node.value != \"undefined\"){\n                    curnode.value = node.value;\n                }\n                local.push(curnode);\n                curnode.params = [];\n                this._nodeWalker(node.childNodes, curnode.params);\n            }\n\n        }else if(node.type == this.types.GROUP){\n            curnode = [];\n            local.push(curnode);\n            this._nodeWalker(node.childNodes, curnode);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-inbox/node_modules/inbox/lib/xoauth.js":"\"use strict\";\n\n// this module is inspired by xoauth.py\n// http://code.google.com/p/google-mail-xoauth-tools/\n\nvar crypto = require(\"crypto\");\n\n/**\n * Expose to the world\n * @namespace xoauth\n */\nmodule.exports.XOAuthGenerator = XOAuthGenerator;\n\n/**\n * Create a XOAUTH login token generator\n *\n * @constructor\n * @memberOf xoauth\n * @param {Object} options\n * @param {String} [options.consumerKey=\"anonymous\"] OAuth consumer key\n * @param {String} [options.consumerSecret=\"anonymous\"] OAuth consumer secret\n * @param {String} [options.requestorId] 2 legged OAuth requestor ID\n * @param {String} [options.nonce] Nonce value to be used for OAuth\n * @param {Number} [options.timestamp] Unix timestamp value to be used for OAuth\n * @param {String} options.user Username\n * @param {String} [options.requestUrl] OAuth request URL\n * @param {String} [options.method=\"GET\"] OAuth request method\n * @param {String} options.token OAuth token\n * @param {String} options.tokenSecret OAuth token secret\n */\nfunction XOAuthGenerator(options){\n    this.options = options || {};\n}\n\n/**\n * Generate a XOAuth login token\n *\n * @param {Function} [callback] Callback function to run when the access token is genertaed\n * @return {String|undefined} If callback is not set, return the token value, otherwise run callback instead\n */\nXOAuthGenerator.prototype.generate = function(callback){\n    return generateXOAuthStr(this.options, callback);\n};\n\n// Helper functions\n\nfunction escapeAndJoin(arr){\n    return arr.map(encodeURIComponent).join(\"&\");\n}\n\nfunction hmacSha1(str, key){\n    var hmac = crypto.createHmac(\"sha1\", key);\n    hmac.update(str);\n    return hmac.digest(\"base64\");\n}\n\nfunction initOAuthParams(options){\n    return {\n            oauth_consumer_key: options.consumerKey || \"anonymous\",\n            oauth_nonce: options.nonce || \"\" + Date.now() + Math.round(Math.random()*1000000),\n            oauth_signature_method: \"HMAC-SHA1\",\n            oauth_version: \"1.0\",\n            oauth_timestamp: options.timestamp || \"\" + Math.round(Date.now()/1000)\n        };\n}\n\nfunction generateOAuthBaseStr(method, requestUrl, params){\n    var reqArr = [method, requestUrl].concat(Object.keys(params).sort().map(function(key){\n            return key + \"=\" + encodeURIComponent(params[key]);\n        }).join(\"&\"));\n    return escapeAndJoin(reqArr);\n}\n\nfunction generateXOAuthStr(options, callback){\n    options = options || {};\n\n    var params = initOAuthParams(options),\n        requestUrl = options.requestUrl || \"https://mail.google.com/mail/b/\" + (options.user || \"\") + \"/imap/\",\n        baseStr, signatureKey, paramsStr, returnStr;\n\n    if(options.token && !options.requestorId){\n        params.oauth_token = options.token;\n    }\n\n    baseStr = generateOAuthBaseStr(options.method || \"GET\", requestUrl, params);\n\n    if(options.requestorId){\n        baseStr += encodeURIComponent(\"&xoauth_requestor_id=\" + encodeURIComponent(options.requestorId));\n    }\n\n    signatureKey = escapeAndJoin([options.consumerSecret || \"anonymous\", options.tokenSecret || \"\"]);\n\n    params.oauth_signature = hmacSha1(baseStr, signatureKey);\n\n    paramsStr = Object.keys(params).sort().map(function(key){\n        return key+\"=\\\"\"+encodeURIComponent(params[key])+\"\\\"\";\n    }).join(\",\");\n\n    // Liidab kokku heks pikaks stringiks kujul \"METHOD URL BODY\"\n    // 2-legged variandi puhul lisab BODY parameetritele otsa ka requestor_id vrtuse\n    returnStr = [options.method || \"GET\", requestUrl +\n            (options.requestorId ? \"?xoauth_requestor_id=\" + encodeURIComponent(options.requestorId) : \"\"), paramsStr].join(\" \");\n\n    if(typeof callback == \"function\"){\n        callback(null, new Buffer(returnStr, \"utf-8\").toString(\"base64\"));\n    }else{\n        return new Buffer(returnStr, \"utf-8\").toString(\"base64\");\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-inbox/node_modules/inbox/lib/mailbox.js":"\"use strict\";\n\nvar mailboxNames = require(\"./names.json\");\n\n/**\n * Expose to the world\n * @namespace mailbox\n */\nmodule.exports.Mailbox = Mailbox;\nmodule.exports.detectMailboxType = detectMailboxType;\n\n/**\n * Create a mailbox object\n *\n * @memberOf mailbox\n * @constructor\n * @param {Object} options Options object\n */\nfunction Mailbox(options){\n    options = options || {};\n\n    Object.defineProperty(this, \"client\", {\n        value: options.client || {},\n        enumerable: false\n    });\n\n    Object.defineProperty(this, \"tags\", {\n        value: options.tags || [],\n        enumerable: false,\n        writable: true\n    });\n\n    this.name = options.name || \"\";\n    this.path = options.path || this.name;\n    this.type = options.type || (this.client._capabilities.indexOf(\"XLIST\")<0 && this.detectType() || \"Normal\");\n    this.delimiter = options.delimiter || this.client._mailboxDelimiter || \"\";\n}\n\n/**\n * Open the mailbox\n *\n * @param {Object} [options] Optional options object\n * @param {Boolean} [options.readOnly] If set to true, open the mailbox in read-only mode (seen/unseen flags won't be touched)\n * @param {Function} callback Callback function to run when the mailbox is opened\n */\nMailbox.prototype.open = function(options, callback){\n    this.client.openMailbox(this.path, options, callback);\n};\n\n/**\n * Detects the type by the name of the mailbox\n */\nMailbox.prototype.detectType = function(){\n    return detectMailboxType(this.name);\n};\n\n/**\n * Lists children for the mailbox\n *\n * @param {String} [path] If set, list only selected path info but not the children\n * @param {Function} callback Callback function to run with the mailbox list\n */\nMailbox.prototype.listChildren = function(path, all, callback){\n    if(!callback && typeof all == \"function\"){\n        callback = all;\n        all = undefined;\n    }\n\n    if(!callback && typeof path == \"function\"){\n        callback = path;\n        path = undefined;\n    }\n\n    var command = \"LIST\", suffix = \"\", wildcard = all ? \"*\" : \"%\";\n\n    path = this.client._escapeString(path || (this.path ? this.path + this.delimiter + wildcard : wildcard));\n\n    if(this.client._capabilities.indexOf(\"SPECIAL-USE\")>=0){\n        command = \"LIST\";\n        suffix = \" RETURN (SPECIAL-USE)\";\n    }else if(this.client._capabilities.indexOf(\"XLIST\")>=0){\n        command = \"XLIST\";\n    }\n\n    this.client._send(command+\" \"+this.client._escapeString(this.client._rootPath) + \" \" + path + suffix,\n        (function(){\n            this.listSubscribed(path, this.client._mailboxList, callback);\n        }).bind(this),\n        (function(){\n            this.client._mailboxList = [];\n        }).bind(this));\n\n};\n\n/**\n * Fetches subscribed mailboxes\n *\n * @param {String} path Parent mailbox\n * @param {Array} xinfo Results from XLIST or LIST\n * @param {Function} callback Callback function to run with the mailbox list\n */\nMailbox.prototype.listSubscribed = function(path, xinfo, callback){\n    if(!callback && typeof xinfo == \"function\"){\n        callback = xinfo;\n        xinfo = undefined;\n    }\n\n    xinfo = xinfo || [];\n\n    this.client._send(\"LSUB \"+this.client._escapeString(this.client._rootPath)+\" \"+path,\n        (function(status){\n            if(!this.client._mailboxList.length){\n                this.client._mailboxList = [].concat(xinfo);\n            }\n            this.client._handlerTaggedLsub(xinfo, callback, status);\n        }).bind(this),\n        (function(){\n            this.client._mailboxList = [];\n        }).bind(this));\n};\n\n/**\n * Creates a new mailbox and subscribes to it\n *\n * @param {String} name Name of the mailbox\n * @param {Function} callback Callback function to run with the created mailbox object\n */\nMailbox.prototype.createChild = function(name, callback){\n    var path = (this.path ? this.path + this.delimiter + name:name);\n    this.client._send(\"CREATE \"+this.client._escapeString(path), (function(status){\n        if(status == \"OK\"){\n            this.client._send(\"SUBSCRIBE \"+this.client._escapeString(path), (function(){\n                if(typeof callback == \"function\"){\n                    callback(null, new Mailbox({\n                        client: this.client,\n                        path: path,\n                        name: name,\n                        delimiter: this.delimiter,\n                        tags: []\n                    }));\n                }\n            }).bind(this));\n        }else{\n            callback(new Error(\"Creating mailbox failed\"));\n        }\n    }).bind(this));\n};\n\n/**\n * Deletes a mailbox\n *\n * @param {String} name Name of the mailbox\n * @param {Function} callback Callback function to run with the status of the operation\n */\nMailbox.prototype.deleteChild = function(name, callback){\n    var path = (this.path ? this.path + this.delimiter + name:name);\n    this.client._send(\"DELETE \"+this.client._escapeString(path), (function(status){\n        if(status == \"OK\"){\n            callback(null, status);\n        }else{\n            callback(new Error(\"Deleting mailbox failed\"));\n        }\n    }).bind(this));\n};\n\n/**\n * Returns mailbox type detected by the name of the mailbox\n *\n * @param {String} mailboxName Mailbox name\n * @return {String} Mailbox type\n */\nfunction detectMailboxType(mailboxName){\n    mailboxName = (mailboxName || \"\").toString().trim().toLowerCase();\n\n    if(mailboxNames.sent.indexOf(mailboxName)>=0){\n        return \"Sent\";\n    }\n\n    if(mailboxNames.trash.indexOf(mailboxName)>=0){\n        return \"Trash\";\n    }\n\n    if(mailboxNames.junk.indexOf(mailboxName)>=0){\n        return \"Junk\";\n    }\n\n    if(mailboxNames.drafts.indexOf(mailboxName)>=0){\n        return \"Drafts\";\n    }\n\n    return \"Normal\";\n}\n","/home/travis/build/npmtest/node-npmtest-inbox/node_modules/inbox/tools/clientplayground.js":"var inbox = require(\"..\"),\n    util = require(\"util\");\n\nvar client = inbox.createConnection(false, \"imap.gmail.com\", {\n    secureConnection: true,\n    auth:{\n        user: \"test.nodemailer@gmail.com\",\n        pass: \"Nodemailer123\"\n    },\n    debug: true\n});\n\nclient.connect();\n\nclient.on(\"connect\", function(){\n    client.openMailbox(\"INBOX\", function(error, mailbox){\n        if(error) throw error;\n\n        // List newest 10 messages\n        client.listMessages(-10, function(err, messages){\n            messages.forEach(function(message){\n                console.log(message.UID+\": \"+message.title);\n            });\n        });\n\n        /*\n        client.fetchData(52, function(err, message){\n            console.log(message);\n        });\n\n        //var stream = client.createMessageStream(52);\n        //client.createMessageStream(52).pipe(process.stdout, {end: false});\n\n        client.updateFlags(52, [\"\\\\Answered\", \"\\\\Flagged\"], \"+\", console.log)\n        client.removeFlags(52, [\"\\\\Answered\", \"\\\\Flagged\"], console.log)\n        client.addFlags(52, [\"\\\\Flagged\"], console.log)\n        */\n\n        function walkMailboxes(name, level, node){\n            level = level || 0;\n            (node.listChildren || node.listMailboxes).call(node, function(err, list){\n                if(err){return;}\n                console.log(\"> \"+name);\n                for(var i=0; i<list.length; i++){\n                   console.log(list[i]);\n                   if(list[i].hasChildren){\n                        walkMailboxes(list[i].name, level+1, list[i]);\n                   }\n                }\n            });\n        }\n\n        console.log(12)\n        client.getMailbox(\"[Gmail]/Saadetud kirjad\", console.log);\n\n        //walkMailboxes(\"ROOT\", 0, client);\n        /*\n        client.listMailboxes(function(error, mailboxes){\n            console.log(mailboxes)\n            mailboxes.forEach(function(mailbox){\n                if(mailbox.hasChildren){\n                    mailbox.createChild(\"andristest\", console.log);\n                }\n            })\n        });\n        */\n\n        //client.listChildren(console.log)\n\n        client.createMailbox('test/foobar', function (err, mailbox) {\n            console.log(err, mailbox);\n            client.deleteMailbox('test/foobar', console.log);\n        });\n\n    });\n\n    // on new messages, print to console\n    client.on(\"new\", function(message){\n        console.log(\"New message:\");\n        console.log(util.inspect(message, false, 7));\n\n        client.createMessageStream(message.UID).pipe(process.stdout, {end: false});\n\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-inbox/node_modules/inbox/tools/parserplayground.js":"var IMAPLineParser = require(\"../lib/lineparser\");\n\nvar cp = new IMAPLineParser();\n\n//cp.write(\"A654 FETCH 2:4 (FLAGS BODY[HEADER.FIELDS (DATE FROM)])\");\n//cp.write(\"* 23 FETCH (FLAGS (\\\\Seen) UID 4827313)\");\n/*\ncp.write(\"* 12 FETCH (BODY[HEADER] {342}\");\ncp.writeLiteral(\"TERE TERE\");\ncp.write(\" BODY[RFC] {123}\");\ncp.writeLiteral(\"VANA KERE\");\ncp.write(\")\");\n\ncp.end();\n*/\n\ncp.on(\"line\", function(line){console.log(require(\"util\").inspect(line, false, 11));});\n\ncp.write(\"* 12 FETCH (FLAGS (\\\\Seen) INTERNALDATE \\\"17-Jul-1996 02:44:25 -0700\\\" RFC822.SIZE 4286 ENVELOPE (\\\"Wed, 17 Jul 1996 02:23:25 -0700 (PDT)\\\" \\\"IMAP4rev1 WG mtg summary and minutes\\\" ((\\\"Terry Gray\\\" NIL \\\"gray\\\" \\\"cac.washington.edu\\\")) ((\\\"Terry Gray\\\" NIL \\\"gray\\\" \\\"cac.washington.edu\\\")) ((\\\"Terry Gray\\\" NIL \\\"gray\\\" \\\"cac.washington.edu\\\")) ((NIL NIL \\\"imap\\\" \\\"cac.washington.edu\\\")) ((NIL NIL \\\"minutes\\\" \\\"CNRI.Reston.VA.US\\\") (\\\"John Klensin\\\" NIL \\\"KLENSIN\\\" \\\"MIT.EDU\\\")) NIL NIL \\\"<B27397-0100000@cac.washington.edu>\\\") BODY (\\\"TEXT\\\" \\\"PLAIN\\\" (\\\"CHARSET\\\" \\\"US-ASCII\\\") NIL NIL \\\"7BIT\\\" 3028 92)) () B[]\");\n\ncp.end();\n\ncp.end(\"* OK [ALERT] System shutdown in 10 minutes\");\n\ncp.end(\"BODY[]<0.2048>\");\n\n\n\n\n//console.log(require(\"util\").inspect(cp.end(), false, 11));\n\n//console.log(require(\"util\").inspect(parseLine(\"14 FETCH (FL\\\\AGS (\\\\Seen \\\\Dele\"), false, 7));\n\n","/home/travis/build/npmtest/node-npmtest-inbox/node_modules/inbox/tools/proxy.js":"var net = require('net'),\n    tls = require('tls'),\n    fs = require(\"fs\");\n\nvar targetHost = \"imap.gmail.com\",//\"imap-mail.outlook.com\",\n    targetPort = 993,\n    targetSecure = true,\n    logfile = \"log_\",\n    proxyPort = 143;\n\nvar sessionCounter = 0,\n\n    server = net.createServer(function(client) { //'connection' listener\n        console.log('Client connected');\n        var socket, target, session = ++sessionCounter;\n\n        var logStream = fs.createWriteStream(logfile + session + \".txt\");\n\n        client.on('end', function() {\n            console.log('Client disconnected');\n            if(socket && !socket.destroyed){\n                socket.end();\n            }\n        });\n\n        client.on('data', function(chunk) {\n            var str = (chunk || \"\").toString(\"utf-8\").trim();\n            if(str){\n                console.log(\"CLIENT (\"+session+\"): \" + str);\n                if(logStream){\n                    logStream.write(\"~~~~~~~~~~~~~~~~~= CLIENT (\"+session+\") =~~~~~~~~~~~~~~~~~~\\r\\n\"+str+\"\\r\\n\");\n                }\n            }\n        });\n\n        client.on('error', function(err) {\n            console.log(\"Client error\");\n            console.log(err);\n            if(socket && !socket.destroyed){\n                socket.end();\n            }\n        });\n    console.log(targetPort, targetHost)\n        var params = [targetPort, targetHost, function() {\n\n                console.log(\"Server connected\");\n\n                socket = targetSecure ? target.socket : target;\n\n                socket.setKeepAlive(true);\n\n                if(client && !client.destroyed){\n                    client.pipe(target);\n                }else{\n                    socket.end();\n                }\n\n            }];\n\n        if(targetSecure){\n            params.shift();\n            params.shift();\n            params.unshift({\n                port: targetPort,\n                host: targetHost\n            });\n        }\n\n        var target = (targetSecure?tls:net).connect.apply((targetSecure?tls:net), params);\n\n        target.on('data', function(chunk) {\n            var str = (chunk || \"\").toString(\"utf-8\").trim();\n            if(str){\n                console.log(\"SERVER (\"+session+\"): \" + str);\n                if(logStream){\n                    logStream.write(\"~~~~~~~~~~~~~~~~~= SERVER (\"+session+\") =~~~~~~~~~~~~~~~~~~\\r\\n\"+str+\"\\r\\n\");\n                }\n            }\n\n            // do not announce compression support on IMAP\n            if(str.match(/\\bCOMPRESS\\=[\\w]+/)){\n                chunk = new Buffer(str.replace(/COMPRESS\\=[\\w]+/g, \"\").trim()+\"\\r\\n\", \"utf-8\");\n            }\n\n            client.write(chunk);\n        });\n\n        target.on('end', function() {\n            console.log(\"Server disconnected\");\n            client.end();\n        });\n\n        target.on('error', function(err) {\n            console.log(\"Server error\");\n            console.log(err);\n            client.end();\n        });\n\n    });\n\nserver.listen(proxyPort, function() { //'listening' listener\n    console.log('Proxy bound');\n});"}